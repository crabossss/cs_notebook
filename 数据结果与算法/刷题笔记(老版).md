# 刷题笔记



## 一、二叉树部分



**二叉树递归算法方法论：**

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



### 1、二叉树定义

c++:

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

java:

```java
public class TreeNode {
    int val;
  	TreeNode left;
  	TreeNode right;
  	TreeNode() {}
  	TreeNode(int val) { this.val = val; }
  	TreeNode(int val, TreeNode left, TreeNode right) {
    		this.val = val;
    		this.left = left;
    		this.right = right;
  	}
}
```

N叉树定义：

```java
class Node {
    public int val;
    public List<Node> children;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};
```



### 2、递归转迭代

前序遍历：

```java
// 前序遍历顺序：中-左-右，入栈顺序：中-右-左
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root); //根节点先入栈
        while (!stack.isEmpty()){
            TreeNode node = stack.pop(); //中节点出栈
            result.add(node.val);
            if (node.right != null){
                stack.push(node.right); //右节点入栈（先入后出）
            }
            if (node.left != null){
                stack.push(node.left); //左节点入栈
            }
        }
        return result;
    }
}
```

后序遍历：

```java
// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root); //根节点入栈
        while (!stack.isEmpty()){
            TreeNode node = stack.pop(); //中节点出栈
            result.add(node.val);
            if (node.left != null){
                stack.push(node.left); //左节点入栈（先入后出）
            }
            if (node.right != null){
                stack.push(node.right); //右节点入栈
            }
        }
        Collections.reverse(result); //数组翻转
        return result;
    }
}
```

中序遍历：

```java
// 中序遍历顺序: 左-中-右 入栈顺序： 左-右
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
           if (cur != null){
               stack.push(cur);
               cur = cur.left; //一直向左遍历入栈直至最左端叶子节点
           }else{
               cur = stack.pop();
               result.add(cur.val);
               cur = cur.right; //遍历子节点的右子节点
           }
        }
        return result;
    }
}
```



### 3、层序遍历

```java
class Solution {
    public List<List<Integer>> resList = new ArrayList<List<Integer>>(); 
    public List<List<Integer>> levelOrder(TreeNode root) {
        if (root == null) return resList;
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int len = queue.size(); //记录每一层的节点个数
            List<Integer> list = new ArrayList<Integer>(); //记录每一层元素
            while (len > 0) {
                TreeNode node = queue.poll();
                list.add(node.val);
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
                len --;
            }
            resList.add(list);
        }
        return resList;
    }
}
```



### 4、二叉搜索树

二叉搜索树是一个有序树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树

对于二叉搜索树的迭代算法，其不需要队列或者栈来辅助，由于其有序性，就确定了搜索的方向。

**注意：二叉搜索树的中序遍历是一个递增序列，好好利用这个特性。**

[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

```java
class Solution {
    // 递归，利用二叉搜索树特点，优化
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val) {
            return root;
        }
        if (val < root.val) {
            return searchBST(root.left, val);
        } else {
            return searchBST(root.right, val);
        }
    }
}
```

```java
class Solution {
    // 迭代，利用二叉搜索树特点，优化，可以不需要栈
    public TreeNode searchBST(TreeNode root, int val) {
        while (root != null)
            if (val < root.val) root = root.left;
            else if (val > root.val) root = root.right;
            else return root;
        return root;
    }
}
```



#### 1、利用二叉搜索树中序遍历特性

[剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

利用二叉搜索树的中序遍历，得到递增序列，以此来构造有序链表。注意最后将首位节点串起来。

```java
class Solution {
    Node pre, head;

    public Node treeToDoublyList(Node root) {
        if (root == null) return root;
        dfs(root);
        //最后记得将首位节点串起来
        head.left = pre;
        pre.right = head;
        return head;
    }

    private void dfs(Node cur) {
        if (cur == null) return;
        dfs(cur.left);
        if (pre != null) pre.right = cur; //这一步判断cur是否最左端叶子节点
        else head = cur; //如果pre是null，则将cur为最左端叶子节点，也即链表头
        cur.left = pre;
        pre = cur; 
        dfs(cur.right);
    }
}
```



### 5、Morris遍历



#### 1、中序遍历

**步骤：**

1. 如果当前节点的左孩子为空，则**输出当前节点**并将其右孩子作为当前节点。

2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。

     a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。

     b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。**输出当前节点**。当前节点更新为当前节点的右孩子。

3. 重复以上1、2直到当前节点为空。

下图为每一步迭代的结果（从左至右，从上到下），cur代表当前节点，深色节点表示该节点已输出。

![](https://i.loli.net/2021/11/27/ypV6QrF2e8KES3I.jpg)

```c++
void inorderMorrisTraversal(TreeNode *root) {
    TreeNode *cur = root, *prev = NULL;
    while (cur != NULL)
    {
        if (cur->left == NULL)          // 1.
        {
            printf("%d ", cur->val);
            cur = cur->right;
        }
        else
        {
            // find predecessor
            prev = cur->left;
            while (prev->right != NULL && prev->right != cur)
                prev = prev->right;

            if (prev->right == NULL)   // 2.a)
            {
                prev->right = cur;
                cur = cur->left;
            }
            else                       // 2.b)
            {
                prev->right = NULL;
                printf("%d ", cur->val);
                cur = cur->right;
            }
        }
    }
}
```

**复杂度分析：**

空间复杂度：O(1)，因为只用了两个辅助指针。

时间复杂度：O(n)。证明时间复杂度为O(n)，最大的疑惑在于寻找中序遍历下二叉树中所有节点的前驱节点的时间复杂度是多少，即以下两行代码：

```c++
while (prev->right != NULL && prev->right != cur)
                prev = prev->right;

```

直觉上，认为它的复杂度是O(nlgn)，因为找单个节点的前驱节点与树的高度有关。但事实上，寻找所有节点的前驱节点只需要O(n)时间。n个节点的二叉树中一共有n-1条边，整个过程中每条边最多只走2次，一次是为了定位到某个节点，另一次是为了寻找上面某个节点的前驱节点，如下图所示，其中红色是为了定位到某个节点，黑色线是为了找到前驱节点。所以复杂度为O(n)。

![](https://i.loli.net/2021/11/27/j7lK9dUDZMkuhWx.jpg)



#### 2、前序遍历

前序遍历与中序遍历相似，代码上只有一行不同，不同就在于输出的顺序。

**步骤：**

1. 如果当前节点的左孩子为空，则**输出当前节点**并将其右孩子作为当前节点。

2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。

     a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。**输出当前节点（在这里输出，这是与中序遍历唯一一点不同）。**当前节点更新为当前节点的左孩子。

     b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空。当前节点更新为当前节点的右孩子。

3. 重复以上1、2直到当前节点为空。

![](https://i.loli.net/2021/11/27/IY6kJQ1NXr2ieME.jpg)

```c++
void preorderMorrisTraversal(TreeNode *root) {
    TreeNode *cur = root, *prev = NULL;
    while (cur != NULL)
    {
        if (cur->left == NULL)
        {
            printf("%d ", cur->val);
            cur = cur->right;
        }
        else
        {
            prev = cur->left;
            while (prev->right != NULL && prev->right != cur)
                prev = prev->right;

            if (prev->right == NULL)
            {
                printf("%d ", cur->val);  // the only difference with inorder-traversal
                prev->right = cur;
                cur = cur->left;
            }
            else
            {
                prev->right = NULL;
                cur = cur->right;
            }
        }
    }
}
```



#### 3、后序遍历

后续遍历稍显复杂，需要建立一个临时节点dump，令其左孩子是root。并且还需要一个子过程，就是倒序输出某两个节点之间路径上的各个节点。

**步骤：**

当前节点设置为临时节点dump。

1. 如果当前节点的左孩子为空，则将其右孩子作为当前节点。

2. 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。

     a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。

     b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空。**倒序输出从当前节点的左孩子到该前驱节点这条路径上的所有节点。**当前节点更新为当前节点的右孩子。

3. 重复以上1、2直到当前节点为空。

![](https://i.loli.net/2021/11/27/takCi4X8A1IuLWB.jpg)

```c++
void reverse(TreeNode *from, TreeNode *to) // reverse the tree nodes 'from' -> 'to'.
{
    if (from == to)
        return;
    TreeNode *x = from, *y = from->right, *z;
    while (true)
    {
        z = y->right;
        y->right = x;
        x = y;
        y = z;
        if (x == to)
            break;
    }
}

void printReverse(TreeNode* from, TreeNode *to) // print the reversed tree nodes 'from' -> 'to'.
{
    reverse(from, to);

    TreeNode *p = to;
    while (true)
    {
        printf("%d ", p->val);
        if (p == from)
            break;
        p = p->right;
    }

    reverse(to, from);
}

void postorderMorrisTraversal(TreeNode *root) {
    TreeNode dump(0);
    dump.left = root;
    TreeNode *cur = &dump, *prev = NULL;
    while (cur)
    {
        if (cur->left == NULL)
        {
            cur = cur->right;
        }
        else
        {
            prev = cur->left;
            while (prev->right != NULL && prev->right != cur)
                prev = prev->right;

            if (prev->right == NULL)
            {
                prev->right = cur;
                cur = cur->left;
            }
            else
            {
                printReverse(cur->left, prev);  // call print
                prev->right = NULL;
                cur = cur->right;
            }
        }
    }
}
```

空间复杂度同样是O(1)；时间复杂度也是O(n)，倒序输出过程只不过是加大了常数系数。



例题：501



### 6、题目集合

#### 1、单独考虑每层的第一个元素

[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

由于层序遍历时，都是从每层的第一个节点开始考虑，而这里遍历每层的第一个节点时还不知道它的右侧节点是什么，所以每层的第一个节点要单独考虑。有两种思路：第一是把第一个节点拿出循环单独考虑；第二是把每层的第一个节点处理两次；

```java
// 拿出循环单独处理
class Solution {
    public Node connect(Node root) {
        if (root == null) return root;
        Queue<Node> que = new LinkedList<Node>();
        que.offer(root);
        while (!que.isEmpty()) {
            int levelSize = que.size();
            //把每层的第一个元素单独拿出来处理
            Node cur = que.poll(); 
            if (cur.left != null) que.offer(cur.left);
            if (cur.right != null) que.offer(cur.right);
            //从1开始考虑该层剩下的元素
            for (int i = 1; i < levelSize; i ++) {
                Node next = que.poll();
                if (next.left != null) que.offer(next.left);
                if (next.right != null) que.offer(next.right);
                cur.next = next;
                cur = next;
            }
        }
        return root;
    }
}
```

```java
// 每层第一个节点处理两次
class Solution {
    public Node connect(Node root) {
        if (root == null) return root;
        Queue<Node> que = new LinkedList<Node>();
        que.offer(root);
        while (!que.isEmpty()) {
            int levelSize = que.size();
            Node pre = que.peek(); //先直接赋值为每层的第一个节点
            for (int i = 0; i < levelSize; i ++) {
                Node cur = que.poll(); //i=0时，cur和pre其实是同一个节点
                pre.next = cur;
                if (cur.left != null) que.offer(cur.left);
                if (cur.right != null) que.offer(cur.right);
                if (i == levelSize - 1) { //这个判断必须加上，不然某层只有一个节点时会报错
                    cur.next = null;
                } else {
                    pre = cur;
                }
            }
        }
        return root;
    }
}
```



#### 2、翻转二叉树

[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

前序后序遍历都可以进行翻转，但是中序遍历会比较麻烦，因为中序遍历时有些节点的左右孩子会翻转两次(第一次翻转后，进入遍历右子树，而此时的右子树是翻转之前的已经处理过的左子树，则相当于左子树翻转了两次)。

```
//前序遍历
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return root;
        //翻转操作
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
```

中序遍历：

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return root;
        invertTree(root.left);
        //翻转操作
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        invertTree(root.left); //继续翻转左节点，因为左右节点已经互换
        return root;
    }
}
```



#### 3、数的最小\最大深度

注意深度与高度的区别，求深度可以从上到下去查所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中），当求树的总体高度或者深度时，两个概念其实是等价的。

用递归法做时，最好采用后序遍历，对于最小深度，要注意其必须左右子树均为null时才算到叶子节点。

最大深度：

```java
class Solution {
    /**
     * 递归法，前序遍历
     */
    private int res;
    public int maxDepth(TreeNode root) {
        res = 0;
        if (root == null) return res;
        getMaxDepth(root, 1);
        return res;
    }
    private void getMaxDepth(TreeNode node, int depth) {
        res = Math.max(res, depth); //中
        if (node.left == null && node.right == null) return;
        if (node.left != null) { //左
            depth ++;
            getMaxDepth(node.left, depth);
            depth --; //回溯
        }
        if (node.right != null) { //右
            depth ++;
            getMaxDepth(node.right, depth);
            depth --; //回溯
        }
    }
}
```

```java
class solution {
    /**
     * 递归法，后序遍历
     */
    public int maxdepth(treenode root) {
        if (root == null) {
            return 0;
        }
        int leftdepth = maxdepth(root.left); //左
        int rightdepth = maxdepth(root.right); //右
        return math.max(leftdepth, rightdepth) + 1; //中

    }
}
```

```java
class solution {
    /**
     * 迭代法，使用层序遍历
     */
    public int maxdepth(treenode root) {
        if(root == null) {
            return 0;
        }
        deque<treenode> deque = new linkedlist<>();
        deque.offer(root);
        int depth = 0;
        while (!deque.isempty()) {
            int size = deque.size();
            depth++;
            for (int i = 0; i < size; i++) {
                treenode poll = deque.poll();
                if (poll.left != null) {
                    deque.offer(poll.left);
                }
                if (poll.right != null) {
                    deque.offer(poll.right);
                }
            }
        }
        return depth;
    }
}
```

最小深度：

```java
//递归
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        int leftDepth = minDepth(root.left); //左
        int rightDepth = minDepth(root.right); //右
        //中
        if (root.left != null && root.right == null) {
            return 1 + leftDepth;
        }
        if (root.left == null && root.right != null) {
            return 1 + rightDepth;
        }
        return 1 + Math.min(leftDepth, rightDepth);
    }
```

```java
//迭代，层序遍历
class Solution {
    public int minDepth(TreeNode root) {
        int res = 0;
        if (root == null) return res;
        Queue<TreeNode> que = new LinkedList<TreeNode>();
        que.offer(root);
        while (!que.isEmpty()) {
            res ++;
            int length = que.size();
            while (length > 0) {
                TreeNode cur = que.poll();
                if (cur.left != null || cur.right != null) {
                    if (cur.left != null) que.offer(cur.left);
                    if (cur.right != null) que.offer(cur.right);
                } else {
                    return res;
                }
                length --;
            }
        }
        return res;
    }
}
```

N叉树最大深度：

```java
//递归
class Solution {
    public int maxDepth(Node root) {
        if (root == null) return 0;
        int res = 0;
        if (root.children != null) {
            for (Node child : root.children) {
                res = Math.max(res, maxDepth(child));
            }
        }
        return res + 1;
    }
}
```

```java
//迭代，层序遍历
class Solution {
    public int maxDepth(Node root) {
        if (root == null) return 0;
        Queue<Node> que = new LinkedList<>();
        int res = 0;
        que.offer(root);
        while (!que.isEmpty()) {
            int levelSize = que.size();
            for (int i = 0; i < levelSize; i ++) {
                Node cur = que.poll();
                if (cur.children != null) {
                    for (Node child : cur.children) {
                        que.offer(child);
                    }
                }
            }
            res ++;
        }
        return res;
    }
}
```



#### 4、完全二叉树的性质

[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

![222.完全二叉树的节点个数1](https://i.loli.net/2021/11/16/87tqTEnx5CKdIbN.png)

```java
class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        TreeNode leftNode = root, rightNode = root;
        int leftDepth = 0, rightDepth = 0;
        while (leftNode != null) {
            leftDepth ++;
            leftNode = leftNode.left;
        }
        while (rightNode != null) {
            rightDepth ++;
            rightNode = rightNode.right;
        }
        if (leftDepth == rightDepth) return (1 << leftDepth) - 1; //如果是满二叉树，直接返回2^depth - 1
        return countNodes(root.left) + countNodes(root.right) + 1; //否则遍历左右子树
    }
}
```



#### 5、平衡二叉树

[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

这里可以使用-1代表false，这样就使用int类型的返回值同时表示了int和bool类型的两个类型了。

```java
class Solution {
    /*
     * 后序遍历，-1表示非高度平衡二叉树
     */
    private int getHeight(TreeNode root) {
        if (root == null) return 0;
        int leftHeight = getHeight(root.left); //左    
        int rightHeight = getHeight(root.right); //右
        if (leftHeight == -1) return -1; //若子树是非高度平衡二叉树，则直接返回-1
        if (rightHeight == -1) return -1; //若子树是非高度平衡二叉树，则直接返回-1
        if (Math.abs(leftHeight - rightHeight) > 1) { //中
            return -1;
        } 
        return Math.max(leftHeight, rightHeight) + 1;
    }
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        if (getHeight(root) == -1) return false;
        return true;
    }
}
```

这道题只是一个启示，当我们后序遍历二叉树时，先将左右子树的情况先写上，然后在最后考虑中间结点时在取考虑中间节点与其左右子树之间的逻辑；前序遍历也是一样，先考虑中间节点，把其情况先写上，然后在最后考虑左右子树与中间节点之间的逻辑。



#### 6、二叉树的所有路径

[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```jaa
// 递归做法
// 前序遍历 + 回溯
class Solution {
    private void getPath(TreeNode root, List<Integer> path, List<String> res) {
        path.add(root.val); //中
        if (root.left == null && root.right == null) { //如果到达叶子节点，则将该路径输出
            String spath = new String();
            for (int i = 0; i < path.size() - 1; i ++) {
                spath += (String.valueOf(path.get(i)));
                spath += "->";
            }
            spath += (String.valueOf(path.get(path.size() - 1)));
            res.add(spath);
            return;
        }
        if (root.left != null) { //左
            getPath(root.left, path, res);
            path.remove(path.size() - 1); //回溯
        }
        if (root.right != null) { //右
            getPath(root.right, path, res);
            path.remove(path.size()  -1); //回溯
        }
        return;
    }

    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root == null) return res;
        List<Integer> paths = new ArrayList<>();
        getPath(root, paths, res);
        return res;
    }
}
```

```java
// 迭代做法
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> res = new ArrayList<>();
        if (root == null) return res;
        Stack<Object> stk = new Stack<>(); //定义成Object可以同时存入节点和路径值
        stk.push(root); //存入根节点
        stk.push(root.val + ""); //存入根节点路径
        while (!stk.isEmpty()) {
            String path = (String) stk.pop();
            TreeNode cur = (TreeNode) stk.pop();
            if (cur.left == null && cur.right == null) { //到达叶子节点的处理
                res.add(path);
            }
            if (cur.left != null) { //左子树处理（顺序没关系）
                stk.push(cur.left);
                stk.push(path + "->" + cur.left.val); //内部隐藏了回溯过程
            }
            if (cur.right != null) { //右子树处理（顺序没关系）
                stk.push(cur.right);
                stk.push(path + "->" + cur.right.val); //内部隐藏了回溯过程
            }
        }
        return res;
    }
}
```



#### 7、最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

- 若第一次遍历到p或者q，可以直接返回该节点，如果另一个所求节点在该节点的子树中，则该节点一定是最近公共祖先节点。

- 考虑中节点时，对于其左右子树的遍历结果有四种情况：

1. 当 left 和 right 同时为空 ：说明 rootroot 的左 / 右子树中都不包含 p,q，返回 null ；
2. 当 left 和 right 同时不为空 ：说明 p,q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ；
3. 当 left 为空 ，right 不为空 ：p,q 都不在root 的左子树中，直接返回 right 。具体可分为两种情况：
   1. p,q其中一个在 root 的 右子树 中，此时 right 指向 p（假设为 p ）；
   2. p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；
4. 当 left 不为空 ， right 为空 ：与情况 3. 同理；

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) return root; //当越过叶子节点或者遍历到p或者q时直接返回
        TreeNode leftChild = lowestCommonAncestor(root.left, p, q); //左子树
        TreeNode rightChild = lowestCommonAncestor(root.right, p, q); //右子树
        // 考虑中节点
        if (leftChild == null && rightChild == null) return null;
        if (leftChild == null) return rightChild;
        if (rightChild == null) return leftChild;
        return root;
    }
}
```



#### 8、递归函数什么时候需要返回值

- 如果需要搜索整颗二叉树且不用处理递归返回值，递归函数就不要返回值。（如113.路径总和ii）
- 如果需要搜索整颗二叉树且需要处理递归返回值，递归函数就需要返回值。 （如7、最近公共祖先）
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（如112、路径总和）

[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

```java
//递归做法一
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) return false;
        targetSum -= root.val;
        if (root.left == null && root.right == null && targetSum == 0) return true;
        if (root.left == null && root.right == null) return false;
        if (root.left != null) {
            if (hasPathSum(root.left, targetSum)) return true; //注意这里不需要再target += root.left.val
        }
        if (root.right != null) {
            if (hasPathSum(root.right, targetSum)) return true; //注意这里不需要再target += root.right.val
        }
        return false;
    }
}

//递归做法二
class Solution {
    private boolean traversal(TreeNode root, int count) {
        if (root.left == null && root.right == null && count == 0) return true;
        if (root.left == null && root.right == null) return false;
        
        if (root.left != null) {
            if (traversal(root.left, count -= root.left.val)) return true;
            count += root.left.val; // 回复现场
        }
        if (root.right != null) {
            if (traversal(root.right, count -= root.right.val)) return true;
            count += root.right.val; //回复现场
        }
        return false;
    }
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) return false;
        return traversal(root, targetSum - root.val);
    }
}
```

注意：这里递归做法一不需要回复现场，而递归做法二需要恢复现场的理解：在递归做法一中，在同一层递归函数里。targetSum的值其实是不变的，`targetSum -= root.val;`是在下一层的递归函数中的操作，相当于下一层函数的局部变量，对本层函数的局部变量不产生影响，所以不需要回溯；而递归算法二中，传递函数的参数中就进行了` count -= root.right.val`操作，所以相当于本层中的参数操作，所以还需要做回溯。

```java
//迭代做法
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
         if (root == null) return false;
         Stack<TreeNode> stk1 = new Stack<>(); 
         Stack<Integer> stk2 = new Stack<>();
         stk1.push(root); stk2.push(root.val);
         while (!stk1.isEmpty()) {
             TreeNode node = stk1.pop();
             Integer value = stk2.pop();
             if (node.left == null && node.right == null && value == targetSum) return true;
             if (node.left != null) {
                 stk1.push(node.left); stk2.push(value + node.left.val);
             }
             if (node.right != null) {
                 stk1.push(node.right); stk2.push(value + node.right.val);
             }
         }
```



[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private List<Integer> path = new ArrayList<>();

    private void traversal(TreeNode root, int count) {
        path.add(root.val);
        if (root.left == null && root.right == null && count == 0) {
            res.add(new ArrayList<>(path)); //注意这里要new一个新的数组出来，不然后面回溯恢复现场时会把res里的值改变
            return;
        }
        if (root.left == null && root.right == null) return;
        if (root.left != null) {
            traversal(root.left, count -= root.left.val);
            count += root.left.val;
            path.remove(path.size() - 1);
        }
        if (root.right != null) {
            traversal(root.right, count -= root.right.val);
            count += root.right.val;
            path.remove(path.size() - 1);
        }
        return;
    }

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if (root == null) return res;
        traversal(root, targetSum - root.val);
        return res;
    }
}
```



#### 9、构造二叉树

注意递归时，边界的选择，一搬选择左闭右开区间，具体实现时可以举例子来考虑。

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return traversal(preorder, 0, preorder.length, inorder, 0, inorder.length);
    }
    private TreeNode traversal(int[] preorder, int preLeft, int preRight, int[] inorder, int inLeft, int inRight) {
        if (preRight - preLeft < 1) return null;
        if (preRight - preLeft == 1) return new TreeNode(preorder[preLeft]);
        TreeNode root = new TreeNode(preorder[preLeft]);
        int rootIndex = 0;
        for (int i = inLeft; i < inRight; i ++) {
            if (inorder[i] == root.val) {
                rootIndex = i;
                break;
            }
        }
        root.left = traversal(preorder, preLeft + 1, preLeft + 1 + (rootIndex - inLeft), inorder, inLeft, rootIndex);
        root.right = traversal(preorder, preLeft + 1 + (rootIndex - inLeft), preRight, inorder, rootIndex + 1, inRight);
        return root;
    }
}
```

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return traversal(inorder, 0, inorder.length, postorder, 0, postorder.length);
    }
    private TreeNode traversal(int[] inorder, int inLeft, int inRight,
                      int[] postorder, int posLeft, int posRight) {
        if (inRight - inLeft < 1) return null;
        if (inRight - inLeft == 1) return new TreeNode(inorder[inLeft]);
        TreeNode root = new TreeNode(postorder[posRight - 1]);
        int rootIndex = 0;
        for (int i = inLeft;i < inRight; i ++) {
            if (inorder[i] == root.val) {
                rootIndex = i;
                break;
            }
        }
        root.left = traversal(inorder, inLeft, rootIndex, postorder, posLeft, posLeft + rootIndex - inLeft);
        root.right = traversal(inorder, rootIndex + 1, inRight, postorder, posLeft + rootIndex - inLeft, posRight - 1);
        return root;
    }
}
```



#### 10、二叉搜索树中的众数

[501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

二叉搜索树的中序遍历是有序的，所以可以直接用来比较前后两个遍历结果来判断数的出现频率。

```java
//递归实现
class Solution {
    private List<Integer> resList = new ArrayList<>();
    TreeNode pre = null;
    int count = 0, maxCount = 0;

    public int[] findMode(TreeNode root) {
        do_findMode(root);
        int[] res = new int[resList.size()];
        for (int i = 0; i < resList.size(); i ++) {
            res[i] = resList.get(i);
        }
        return res;
    }

    private void do_findMode(TreeNode root) {
        if (root == null) return;
        do_findMode(root.left);
        // 当是遍历的第一个元素时，或者遍历的前后元素发生改变时，做赋1操作，否则，就是遍历相同的元素，做加1操作
        if (pre == null || root.val != pre.val) { // 只有遍历第一个元素，或者前后元素值发生变化时才赋1
            count  = 1;
        } else {
            count ++;
        } 
        // 注意，以下语句不用放到上方判断语句里，只要count > maxCount，则做刷新数组操作，count = maxCount，则做添加操作，
        // 当然，这里对于某个值可能会先做添加操作，然后再做刷新操作，但最终结果都是可行的
        if (count > maxCount) {
                resList.clear();
                resList.add(root.val);
                maxCount = count; // 不要忘了更新最大值
        } else if (count == maxCount) {
            resList.add(root.val);
        }
        pre = root;

        do_findMode(root.right);
    }
}
```



#### 11、删除二叉树搜索树中的节点

要分五种情况讨论：

- 第一种情况：没找到删除的节点，遍历到空节点直接返回了
- 找到删除的节点
  - 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
  - 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
  - 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
  - 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。

[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

```java
//递归写法
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null; //第一种情况，树中没有对应节点，直接返回null
        if (root.val == key) {
            if (root.left == null && root.right == null) return null; //第二种情况，叶子节点上，直接删除叶子节点返回null
            if (root.left == null) return root.right; //第三种情况，左子树为空，直接返回右子树
            if (root.right == null) return root.left; //第四种情况，右子树为空，直接返回左子树
            TreeNode cur = root.right; //第五种情况，左右子树均不为空，则将左子树接在右子树的最左端叶子节点上，返回右子树
            while (cur.left != null) cur = cur.left;
            cur.left = root.left;
            return root.right; 
        }
        if (root.val > key) root.left = deleteNode(root.left, key);
        if (root.val < key) root.right = deleteNode(root.right, key);
        return root;
    }
}
```

```java
// 迭代做法
class Solution {
    private TreeNode deleteOne(TreeNode root) { //五种情况可以简化成如下代码
        if (root == null) return null;
        if (root.right == null) return root.left;
        TreeNode tmp = root.right;
        while (tmp.left != null) tmp = tmp.left;
        tmp.left = root.left;
        return root.right;
    }

    public TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;
        TreeNode pre = null; //用来记录待删除节点的父节点
        TreeNode cur = root; //记录待删除节点
        while (cur != null) {
            if (cur.val == key) break; //遍历到待删除节点，则直接退出
            pre = cur;
            if (cur.val > key) cur = cur.left;
            else cur = cur.right;
        }
        if (pre == null) return deleteOne(root); //如果pre = null则说明待删除节点是根节点
        if (pre.left != null && pre.left.val == key) { //判断待删除节点是否父节点的左节点
            pre.left = deleteOne(cur);
        }
        if (pre.right != null && pre.right.val == key) { //判断待删除节点是否父节点的右节点
            pre.right = deleteOne(cur);
        }
        return root;
    }
}
```



#### 12、修剪二叉树

[669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

前序遍历，先考虑中间节点，如果中间节点在区间左边，则返回其右子树的遍历结果，如果中间节点在区间右边，则返回其左子树的遍历结果，当中间节点在区间内时，则分别考虑其左右子节点。返回中间节点。

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if (root == null) return null;
        if (root.val < low) return trimBST(root.right, low, high);
        if (root.val > high) return trimBST(root.left, low, high);
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
}
```



#### 13、将有序数组转换成二叉搜索树

[108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```java
// 递归写法
class Solution {
    private TreeNode process(int[] nums, int leftIndex, int rightIndex) { //左闭右开
        if (rightIndex - leftIndex < 1) return null;
        int midIndex = leftIndex + (rightIndex - leftIndex) / 2;
        TreeNode root = new TreeNode(nums[midIndex]);
        root.left = process(nums, leftIndex, midIndex);
        root.right = process(nums, midIndex + 1, rightIndex);
        return root; 
    }
    public TreeNode sortedArrayToBST(int[] nums) {
        return process(nums, 0, nums.length);
    }
}
```

重点关注该迭代实现，首先在循环外部定义一个空节点，空节点的赋值在循环内部实现，同时，遍历左右子树时，也是先定义左右子节点，左右子节点的具体赋值在下一层循环中实现，当遇到迭代写法中，左右子树处理不知道逻辑时，可以参考其父节点的实现逻辑，来分别处理左右子节点。

```
//迭代实现
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        TreeNode root = new TreeNode(); //首先定义一个空节点，其具体赋值在循环内部实现
        Queue<TreeNode> queueNode = new LinkedList<>();
        Queue<Integer> queueLeftIndex = new LinkedList<>();
        Queue<Integer> queueRightIndex = new LinkedList<>();
        queueNode.offer(root);
        queueLeftIndex.offer(0);
        queueRightIndex.offer(nums.length - 1); //左闭右闭
        while (!queueNode.isEmpty()) {
            TreeNode cur = queueNode.poll();
            int leftIndex = queueLeftIndex.poll();
            int rightIndex = queueRightIndex.poll();
            int midIndex = leftIndex + (rightIndex - leftIndex) / 2;
            cur.val = nums[midIndex]; //实现父节点赋值操作
            if (leftIndex < midIndex) { //若左子树存在
                cur.left = new TreeNode(); //同样的逻辑，先定义左子节点，下一层循环具体赋值
                queueNode.offer(cur.left);
                queueLeftIndex.offer(leftIndex);
                queueRightIndex.offer(midIndex - 1);
            }
            if (rightIndex > midIndex) { //若右子树存在
                cur.right = new TreeNode(); //同样的逻辑，先定义右子节点，下一层循环具体赋值
                queueNode.offer(cur.right);
                queueLeftIndex.offer(midIndex + 1);
                queueRightIndex.offer(rightIndex);
            }
        }
        return root;
    }
}  
```



#### 14、数组与二叉树的关系

当二叉树为完全二叉树时，用数组来表示二叉树是比较方便遍历的，下标从1开始，对于第i个节点，其左子树的下标为2 * i，右子树的下标为2 * i + 1。

对于普通二叉树，如果用上述数组表示的话，是比较耗费空间的，可以采用层序遍历的方式将二叉树存储在数组中，如下图所示：

![](https://pic.leetcode-cn.com/1603117385-ehAGsP-Picture1.png)

下标从0开始，其中m表示区间[0, n]中null节点个数：

![image-20220512203159452](C:/Users/xwq98/AppData/Roaming/Typora/typora-user-images/image-20220512203159452.png)

[剑指 Offer 37. 序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/)

题解：

```java
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) return "[]";
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        StringBuilder sb = new StringBuilder();
        while (!queue.isEmpty()) {
            TreeNode cur = queue.poll();
            if (cur != null) {
                sb.append(String.valueOf(cur.val) + ",");
                queue.offer(cur.left);
                queue.offer(cur.right);
            } else {
                sb.append("null,");
            }
        }
        String res = "[" + sb.toString().substring(0, sb.length() - 1) + "]";
        return res;
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data.equals("[]")) return null;
        String[] strs = data.substring(1, data.length() - 1).split(",");
        TreeNode root = new TreeNode(Integer.parseInt(strs[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;
        while (!queue.isEmpty()) {
            TreeNode cur = queue.poll();
            if (strs[i].equals("null")) {
                cur.left = null;
            } else {
                TreeNode left = new TreeNode(Integer.parseInt(strs[i]));
                cur.left = left;
                queue.offer(left);
            }
            i ++;
            if (strs[i].equals("null")) {
                cur.right = null;
            } else {
                TreeNode right = new TreeNode(Integer.parseInt(strs[i]));
                cur.right = right;
                queue.offer(right);
            }
            i ++;
        }
        return root;
    }
}
```



## 二、动态规划



**方法论：**

1. **确定dp数组（dp table）以及下标的含义**
2. **确定递推公式**：注意是要定义为二维数组，还是定义为一维数组
3. **dp数组如何初始化**
4. **确定遍历顺序**：可以画出示意图，看怎么转换的
5. **举例推导dp数组**



### 1、背包问题



#### 1、0/1背包问题

![](https://i.loli.net/2021/10/27/oE7aTF2KdvX9xyf.png)

1. 确定dp数组以及下标的含义

   对于背包问题，有一种写法， 是使用二维数组，即`dp[i][j] `表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。

2. 确定递推公式

   有两个方向推出来`dp[i][j]`，

   - **不放物品i**：由`dp[i - 1][j]`推出，即背包容量为j，里面不放物品i的最大价值，此时`dp[i`][j]就是`dp[i - 1][j]`。
   - **放物品i**：由`dp[i - 1][j - weight[i]]`推出，`dp[i - 1][j - weight[i]] `为背包容量为`j - weight[i]`的时候不放物品i的最大价值，那么`dp[i - 1][j - weight[i]] + value[i] `（物品i的价值），就是背包放物品i得到的最大价值。

   所以递归公式：` dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`;

3. dp数组初始化

   对于n个物体、背包重量为m的场景，这里创建dp数组时，将其创建为`dp[n + 1][m + 1]`，下标从1开始考虑，这样，将dp均初始化为0即可。

4. 遍历顺序

   先遍历物品或者先遍历背包，虽然两个for循环遍历的次序不同，但是`dp[i`][j]所需要的数据在左上角，根本不影响`dp[i`][j]公式的推导！所以两种遍历顺序都行。

5. 举例dp数组

```java
	private static void testWeightBagProblem(int[] weight, int[] value, int bagSize) {
        int[][] dp = new int[weight.length + 1][bagSize + 1];

        for (int i = 1; i <= weight.length; i ++) {
            for (int j = 1; j <= bagSize; j ++) {
                if (j < weight[i - 1]) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);//注意这里weight和value数组的下标需要减一
                }
            }
        }
        for (int i = 0; i <= weight.length; i ++) { //打印dp数组
            for (int j = 0; j <= bagSize; j ++) {
                System.out.print(dp[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagSize = 4;
        testWeightBagProblem(weight, value, bagSize);
    }
```

使用滚动数组优化：

```java
    private static void testWeightBagProblem(int[] weight, int[] value, int bagSize) {
        int[] dp = new int[bagSize + 1];
        for (int i = 1; i <= weight.length; i ++) {
            for (int j = bagSize; j >= weight[i - 1]; j --) { //注意这里必须倒序遍历
                dp[j] = Math.max(dp[j], dp[j - weight[i - 1]] + value[i - 1]);
            }
        }
        for (int i = 0; i < dp.length; i ++) {
            System.out.print(dp[i] + " ");
        }
    }

    public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagSize = 4;
        testWeightBagProblem(weight, value, bagSize);
    }
```



#### 2、完全背包问题

![](https://i.loli.net/2021/10/27/k2RAJpBXEN8dYF5.jpg)

1. 确定dp数组以及下标的含义

   对于背包问题，有一种写法， 是使用二维数组，即`dp[i][j] `表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。

2. 确定递推公式

   这里是与01背包问题的主要区别，01背包问题的`dp[i][j]`只会考虑装不装i这两种情况，而完全背包问题，由于物品无限，所以，需要考虑：**不装物品i、装一件i、装两件i...、装n件i，直到背包容不下(n + 1)件i为止**。故这里有如下表达式：

   `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i],...,dp[i - 1][j - n * weight[i]] + n * value[i])`

   而我们发现：

   `dp[i][j - weight[i]] = max(dp[i - 1][j - weight[i]],...,dp[i - 1][j - n * weight[i]] + (n - 1) * value[i])`

   所以，我们有：

   `dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])`

3. dp数组初始化

   对于n个物体、背包重量为m的场景，这里创建dp数组时，将其创建为`dp[n + 1][m + 1]`，下标从1开始考虑，这样，将dp均初始化为0即可。

4. 遍历顺序

   先遍历物品或者先遍历背包，虽然两个for循环遍历的次序不同，但是`dp[i`][j]所需要的数据在左上角，根本不影响`dp[i`][j]公式的推导！所以两种遍历顺序都行。

   **当用一维数组进行优化时，01背包问题只能先遍历物品，在遍历背包容量；但是在完全背包问题里，两种遍历方式都是可行的。**

5. 举例dp数组

```java
	//先遍历物品，再遍历背包
    private static void testCompletePack(){
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagWeight = 4;
        int[] dp = new int[bagWeight + 1];
        for (int i = 0; i < weight.length; i++){
            for (int j = 1; j <= bagWeight; j++){
                if (j - weight[i] >= 0){
                    dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
                }
            }
        }
        for (int maxValue : dp){
            System.out.println(maxValue + "   ");
        }
    }

    //先遍历背包，再遍历物品
    private static void testCompletePackAnotherWay(){
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagWeight = 4;
        int[] dp = new int[bagWeight + 1];
        for (int i = 1; i <= bagWeight; i++){
            for (int j = 0; j < weight.length; j++){
                if (i - weight[j] >= 0){
                    dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j]);
                }
            }
        }
        for (int maxValue : dp){
            System.out.println(maxValue + "   ");
        }
    }
```



#### 3、多重背包问题

多重背包问题是指每种物品有数量限制，求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。可以直接将多重背包问题**转换成01背包问题**处理。

第一种方法：

将每种物品的数量展开，变成一个一个物品，然后综合考虑。

```c++
void test_multi_pack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    vector<int> nums = {2, 3, 2};
    int bagWeight = 10;
    for (int i = 0; i < nums.size(); i++) {
        while (nums[i] > 1) { // nums[i]保留到1，把其他物品都展开
            weight.push_back(weight[i]);
            value.push_back(value[i]);
            nums[i]--;
        }
    }

    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
        for (int j = 0; j <= bagWeight; j++) {
            cout << dp[j] << " ";
        }
        cout << endl;
    }
    cout << dp[bagWeight] << endl;

}
int main() {
    test_multi_pack();
}
```

第二种方法：

在使用01背包问题来考虑每种物品时，添加一个for循环遍历每种物品的个数

```c++
void test_multi_pack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    vector<int> nums = {2, 3, 2};
    int bagWeight = 10;
    vector<int> dp(bagWeight + 1, 0);


    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            // 以上为01背包，然后加一个遍历个数
            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数
                dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]);
            }
        }
        // 打印一下dp数组
        for (int j = 0; j <= bagWeight; j++) {
            cout << dp[j] << " ";
        }
        cout << endl;
    }
    cout << dp[bagWeight] << endl;
}
int main() {
    test_multi_pack();
}
```

优化：当物体类别较多时，会因时间复杂度过大而不能通过。可以利用二进制数进行优化。

任意一个数n，都可以由其二进制数再加一个常数来表示0-n之间的任意一个数，如200，可以由1，2，4，8，16，32，64以及一个常数73（200-1-2-4-8-16-32-64）来表示0-200之间的任意一个数。

根据上述原理，将物体的类别数量分别由其二进制数外加一个常数来表示，这样就可以将N的复杂度降到logN。再对所有的重组”类别“进行一次01背包问题求解即可。



### 2、打家劫舍问题

[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

这题是对打家劫舍的升级，其邻居围成一个圈，第一家和最后一家临近，只能考虑其中一家进行盗窃。这里可以将该圈分成两种情况来考虑：第一种考虑第一家；第二种考虑最后一家。然后分别对该两种情况使用打家劫舍的动态规划来进行考虑。

```java
class Solution {
    //打家劫舍问题
    private int robCommon(int[] nums, int left, int right) { //左闭右开
        if (right - left <= 1) return nums[left];
        int n = right - left;
        int[] dp = new int[n];
        dp[0] = nums[left];
        dp[1] = Math.max(dp[0], nums[left + 1]);
        for (int i = 2; i < n; i ++) {
            dp[i] = Math.max(dp[i - 2] + nums[left + i], dp[i - 1]);
        }
        return dp[n - 1];
    }
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        //分别考虑
        int result1 = robCommon(nums, 0, nums.length - 1);
        int result2 = robCommon(nums, 1, nums.length);
        return Math.max(result1, result2);
    }
}
```

这里我们发现，其实打家劫舍问题只和`dp[i - 1]`和`dp[i - 2]`有关，所以，我们可以使用三个变量来优化空间复杂度。**对于所有的动态规划问题，当只用到前几个dp数组元素时，都可以使用变量来优化空间复杂度**。

```java
class Solution {
    private int robCommon(int[] nums, int left, int right) { //左闭右开
        int pre = 0, cur = 0, tmp;
        for (int i = left; i < right; i ++) {
            tmp = cur;
            cur = Math.max(cur, pre + nums[i]);
            pre = tmp;
        }
        return cur;
    }
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        int result1 = robCommon(nums, 0, nums.length - 1);
        int result2 = robCommon(nums, 1, nums.length);
        return Math.max(result1, result2);
    }
}
```



### 3、树形DP



[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

这道题考虑在树上做动态规划问题，对于每个父节点，考虑偷于不偷两种情况，当偷父节点时，就不再考虑两个子节点，当不偷父节点时，则考虑两个子节点（注意，这里并不是说不偷父节点就一定要偷其两个子节点，偷不偷两个子节点是一种考虑状态，需要比较来判断），这里的状态转移矩阵用dp[2]来表示，下标为0表示不偷该节点，下标为1表示偷该节点。

由于是树形结构，所以要结合二叉树的遍历三部曲和dp问题的五部曲来综合考虑。这里必须先考虑子节点的状态再来判断偷不偷父节点，所以必须使用后序遍历。

```java
class Solution {
    public int rob(TreeNode root) {
        int[] dp = robTree(root);
        return Math.max(dp[0], dp[1]);
    }
    private int[] robTree(TreeNode root) {
        int[] dp = new int[2];
        if (root == null) return dp;
        int[] leftTree = robTree(root.left);
        int[] rightTree = robTree(root.right);
        //偷root
        dp[1] = root.val + leftTree[0] + rightTree[0];
        //不偷root
        dp[0] = Math.max(leftTree[0], leftTree[1]) + Math.max(rightTree[0], rightTree[1]);
        return dp; 
    }
```

这里之所以要使用一个二维数组来表示，可以将其作为树形dp的做题标准，记住就行。

这道题还可以使用暴力递归+记录状态来做，使用Map来记录每个节点的状态，当遍历到的节点在Map中已经存在则直接返回。这样可以避免暴力遍历的超时问题。虽然事件负责度都是`O(0)`，但是其效果没有dp好。



### 4、股票问题



[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

这道题目可以直接贪心做，考虑每一天，如果在该天抛出股票，那么最大收益肯定是从第一天开始到该天之间股票最小值时买入时收益最大，所以可以记录从0-i之间的最小买入值low，然后用prices[i] - low就是第i天抛出股票所获的最大收益。第0-i天抛出所获收益的最大值就是结果。

```java
//贪心
class Solution {
    public int maxProfit(int[] prices) {
        int low = Integer.MAX_VALUE;
        int res = 0;
        for (int i = 0; i < prices.length; i ++) {
            low = Math.min(low, prices[i]);
            res = Math.max(res, prices[i] - low);
        }
        return res;
    }
}
```

动态规划做法：

`dp[i][0]`表示第i天持有股票时的最大收益，`dp[i][1]`表示第i天抛出股票的最大收益，分析可知，`dp[i][0]`可由`dp[i-1][0]`和`-prices[i]`中的最大值得出(注意，这里不能是`dp[i - 1][1] - prices[i]`，因为股票只能进行一次买卖，到第i天可能已经经历过一次买卖了，`dp[i-1][1]`可能已经是买卖后的值)，`dp[i][1]`可由`dp[i-1][1]`和`dp[i-1][0] + prices[i]`得出，所以可以此来实现递归。

```java
//dp
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (prices == null || n == 0) return 0;
        int[][] dp = new int[n][2]; //dp[i][0]表示第i天持有股票,dp[i][1]表示第i天不持有股票
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; i ++) {
            dp[i][0] = Math.max(dp[i - 1][0], 0 - prices[i]); //注意这里不能是dp[i - 1][1] - prices[i]
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[n - 1][1];
    }
}
```

我们发现，`dp[i]`只和`dp[i - 1]`有关，所以，可以进一步实现空间优化：

```java
//dp空间复杂度优化
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (prices == null || n == 0) return 0;
        int[][] dp = new int[2][2]; 
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; i ++) {
            dp[1][0] = Math.max(dp[0][0], 0 - prices[i]);//注意这里只能是0 - prices[i]
            dp[1][1] = Math.max(dp[0][1], dp[0][0] + prices[i]);
            dp[0][0] = dp[1][0];
            dp[0][1] = dp[1][1];
        }
        return dp[0][1];
    }
}
```



[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

这道题限制了买卖股票的次数，所以相对而言难度加大不少。可以定义一个`n × 5`维的一个数组`dp[n][5]`，其中`dp[i][0]`表示任何不做买卖；`dp[i][1]`表示第i天第一次买入最高收益；`dp[i][2]`表示第i天第一次抛出最高收益;`dp[i][3]`表示第i天第二次买入最高收益；`dp[i][4]`表示第i天第二次抛出最高收益。更多解析见代码。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int n = prices.length;
        int[][] dp = new int[n][5]; 
        //dp[i][0]表示任何不做买卖；dp[i][1]表示第i天第一次买入最高收益；dp[i][2]表示第i天第一次抛出最高收益；
        //dp[i][3]表示第i天第二次买入最高收益；dp[i][4]表示dii天第二次抛出最高收益
        dp[0][0] = 0;
        dp[0][1] -= prices[0];
        dp[0][2] = 0;
        dp[0][3] -= prices[0];//这里可以理解为第一天买入卖出后又买入
        dp[0][4] = 0;
        for (int i = 1; i < n; i ++) {
            dp[i][0] = dp[i - 1][0]; //所有的dp[i][0]其实都是0
            //这里用dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);更加形象表示第i天的第一次买入收益，但是既然dp[i][0]都是0，所以为了美观就无所谓了
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[n - 1][4];
    }
}
```

进一步空间优化：

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int n = prices.length;
        int[] dp = new int[5]; 
        dp[0] = 0;
        dp[1] -= prices[0];
        dp[2] = 0;
        dp[3] -= prices[0];
        dp[4] = 0;
        for (int i = 1; i < n; i ++) {
            dp[1] = Math.max(dp[1],  -prices[i]); 
            dp[2] = Math.max(dp[2], dp[1] + prices[i]);
            dp[3] = Math.max(dp[3], dp[2] - prices[i]);
            dp[4] = Math.max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
    }
}
```



### 5、子序列问题



#### 1、子序列连续与不连续



[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

该题定义的`dp[i][j]`表示考虑nums1数组的第i - 1个元素和nums2数组的第j - 1个元素，当`nums1[i - 1] == nums2[j - 1]`相等时，就对其进行加1操作，递归函数为：`dp[i][j] = dp[i - 1][j - 1] + 1`。

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int res = 0;
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    res = Math.max(res, dp[i][j]);
                }
            }
        }
        return res;
    }
}
```

这里可以使用滚动数组进行空间复杂度的优化，我们发现：在两层for循环内部，`dp[i][j] = dp[i - 1][j - 1] + 1`都是关于j的一个递归，所以，我们可以定义一个关于j的一维数组，对于下表i可以由上一层的直接赋值过来。注意，此时应该避免重复覆盖问题，所以第二层for循环时应该从后往前遍历。

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int res = 0;
        int[] dp = new int[m + 1];
        for (int i = 1; i <= n; i ++) {
            for (int j = m; j > 0; j --) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[j] = dp[j - 1] + 1;
                    res = Math.max(res, dp[j]);
                } else {
                    dp[j] = 0;
                }
            }
        }
        return res;
    }
}
```



[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

这道题不考虑连续性，`dp[i][j]`则表示考虑`text1[i - 1]`和`text2[j - 1]`这两个元素时的最长公共子序列，这时，可以分成两种情况，第一是当`text1[i - 1] == text2[j - 1]`，第二种是`text1[i - 1] != text2[j - 1]`，第一种情况下，直接`dp[i][j] = dp[i - 1][j - 1] + 1`，第二种情况，当`text1[i - 1] != text2[j - 1]`时，这时须考虑`dp[i][j - 1]`和`dp[i - 1][j]`的最大值作为`dp[i][j]`值。

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n = text1.length();
        int m = text2.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[n][m];
    }
}
```



#### 2、编辑距离



[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

这道题目可以直接暴力求解：遍历字符串t，定义一个s的指针（下标）指向开始位置，当发现t中的元素与t当前的元素相同，就给指针往后移一位，当发现指针指向最后一个元素的后一位时，说明匹配完s字符串了，这时输出true，否则输出false.

第二种方法是动态规划，这种方法效率虽然没有暴力高，但是也是一种解法，同时可以与上面的最长公共子序列形成对比学习：

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int n = s.length();
        int m = t.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = dp[i][j - 1]; //注意这里和最长公共子序列的区别
                }
            }
        }
        return dp[n][m] == n;
    }
}
```



[115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

这道题增加难度，要求匹配的个数，此时唯一的不同点在于当`s[i] == t[j]`时，`dp[i][j]`应该由两个部分来组成，即`dp[i - 1][j - 1] + dp[i - 1][j]`，`dp[i - 1][j - 1]`可以理解为使用`s[i]`来匹配`t[j]`，`dp[i - 1][j]`则表示不用`s[i]`来匹配`t[j]`，而是从前`i - 1`个元素中选择一个来匹配`t[j]`，当然，可能匹配不上，则这时`dp[i - 1][j]`就为0了。

```java
class Solution {
    public int numDistinct(String s, String t) {
        int n = s.length(), m = t.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i <= n; i ++) dp[i][0] = 1;
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; //注意这一步
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[n][m];
    }
}
```



[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

这道题目有两个思路：

首先，我们可以转换为求两个字符串的最长子序列，然后用两个字符串的长度减去两倍最长子序列的长度即是答案。

第二种思路就是直接计算删除操作，`dp[i][j]`表示考虑字符串1的前i个元素和字符串2的前j个元素，其最小的删除操作。当`word1[i] == word2[j]`时，则不进行任何删除操作，即`dp[i][j] = dp[i - 1][j - 1]`，当`word1[i] != word2[j]`，则有三种可能性：第一，删除`word1[i]`和`word2[j]`，第二，删除`word1[i]`，第三，删除`word2[j]`，然后取其中的最小值。

```java
//思路一
class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length(), m = word2.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j -1]);
                }
            }
        }
        return (m + n - 2 * dp[n][m]);
    }
}
```

```java
//思路二
class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length(), m = word2.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i <= n; i ++) dp[i][0] = i;
        for (int j = 0; j <= m; j ++) dp[0][j] = j;
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1]+ 2,
                    Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }
        return dp[n][m];
    }
}
```



[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

这里`dp[i][j]`表示考虑word1的前i - 1个元素以及word2的前j - 1个元素，所需要操作的最小步骤。当`word1[i] == word2[j]`时，此时不需要做任何操作，当`word1[i] != word2[j]`时，此时，有三种操作，分别是增、删、改。对于增操作，我们可以理解为`dp[i - 1][j] + 1`，**对于删操作，我们可以理解为word2的增操作**，即`dp[i][j - 1] + 1`，对于改操作，可以表示成`dp[i - 1][j - 1] + 1`。

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length(), m = word2.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i <= n; i ++) dp[i][0] = i;
        for (int j = 0; j <= m; j ++) dp[0][j] = j;
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i][j - 1], Math.min(dp[i - 1][j], dp[i - 1][j - 1])) + 1;
                }
            }
        }
        return dp[n][m];
    }
}
```





### 6、题目集合



#### 1、不同路径

[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

**1、深度优先搜索**

题目中说机器人每次只能向下或者向右移动一步，那么其实机器人走过的路径可以抽象为一颗二叉树，而叶子节点就是终点。此时问题就可以转化为求二叉树叶子节点的个数：

```c++
class Solution {
private:
    int dfs(int i, int j, int m, int n) {
        if (i > m || j > n) return 0; // 越界了
        if (i == m && j == n) return 1; // 找到一种方法，相当于找到了叶子节点
        return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);
    }
public:
    int uniquePaths(int m, int n) {
        return dfs(1, 1, m, n);
    }
};
```

大家如果提交了代码就会发现超时了！

来分析一下时间复杂度，这个深搜的算法，其实就是要遍历整个二叉树。

这颗树的深度其实就是m+n-1（深度按从1开始计算）。

那二叉树的节点个数就是 2^(m + n - 1) - 1。可以理解深搜的算法就是遍历了整个满二叉树（其实没有遍历整个满二叉树，只是近似而已）

所以上面深搜代码的时间复杂度为O(2^(m + n - 1) - 1)，可以看出，这是指数级别的时间复杂度，是非常大的。

**2、动态规划**

按照动规五部曲来分析：

1. 确定dp数组（dp table）以及下标的含义

   `dp[i][j] `：表示从（0 ，0）出发，到(i, j) 有`dp[i][j]`条不同的路径。

2. 确定递推公式

   想要求`dp[i][j]`，只能有两个方向来推导出来，即`dp[i - 1][j] `和` dp[i][j - 1]`。

   `dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`

3. dp数组的初始化

   首先`dp[i][0]`一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么`dp[0][j]`也同理。

   所以初始化代码为：	

```
for (int i = 0; i < m; i++) dp[i][0] = 1;
for (int j = 0; j < n; j++) dp[0][j] = 1;
```

4. 确定遍历顺序

   这里要看一下递归公式`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`，`dp[i][j]`都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。

   这样就可以保证推导`dp[i][j]`的时候，`dp[i - 1][j] `和` dp[i][j - 1]`一定是有数值的。

5. 举例推导dp数组

![](https://camo.githubusercontent.com/0d218e1caf1bde7068b48384c02812d53a9c05bceef33b7ed0a2aa6fd6429851/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313230393131333633313339322e706e67)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i ++) dp[i][0] = 1;
        for (int j = 0; j < n; j ++) dp[0][j] = 1;
        for (int i = 1; i < m; i ++) {
            for (int j = 1; j < n; j ++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

利用滚动数组进行空间优化：

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        for (int i = 0; i < n; i ++) dp[i] = 1;
        for (int i = 1; i < m; i ++) {
            for (int j = 1; j < n; j ++) {
                dp[j] = dp[j - 1] + dp[j];
            }
        }
        return dp[n - 1];
    }
}
```

**3、数论**

m，n的话，无论怎么走，走到终点都需要 m + n - 2 步，在这m + n - 2 步中，一定有 m - 1 步是要向下走的，不用管什么时候向下走。

那么有几种走法呢？ 可以转化为，给你m + n - 2个不同的数，随便取m - 1个数，有几种取法。

![](E:/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9B%BE%E5%BA%93/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313230393131333732353332342e706e67.png)

**求组合的时候，要防止两个int相乘溢出！** 所以不能把算式的分子都算出来，分母都算出来再做除法。

例如如下代码是不行的：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int numerator = 1, denominator = 1;
        int count = m - 1;
        int t = m + n - 2;
        while (count--) numerator *= (t--); // 计算分子，此时分子就会溢出
        for (int i = 1; i <= m - 1; i++) denominator *= i; // 计算分母
        return numerator / denominator;
    }
};
```

需要在计算分子的时候，不断除以分母，代码如下：

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long numerator = 1; // 分子
        int denominator = m - 1; // 分母
        int count = m - 1;
        int t = m + n - 2;
        while (count--) {
            numerator *= (t--);
            while (denominator != 0 && numerator % denominator == 0) {
                numerator /= denominator;
                denominator--;
            }
        }
        return numerator;
    }
};
```

```java
//java版本
//1、分子用long；2、分母初始化为m - 1；3、分子除分母的操作在循环内部进行；
class Solution {
    public int uniquePaths(int m, int n) {
        long numerator = 1; //分子
        int denominator = m - 1; //分母
        int count = m - 1;
        int t = m + n - 2;
        while (count != 0) {
            numerator *= (t --);
            while (denominator != 0 && numerator % denominator == 0) {
                numerator /= denominator;            
                denominator --;
            }
            count --;
        }
        return (int) numerator;
    }
}
```



#### 2、整数拆分

[343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

1、动态规划

`dp[i]`表示整数i的最大乘积，递归公式为：`dp[i] = max(j * (i - j), j * dp[i - j])`,这里为什么不用进一步划分j呢？因为j是从0开始计算的，假如j = 5，如果对j再划分，例如划分成2 + 3，那就是`2 * dp[3] * dp[i - 5]`，而`dp[3] * dp[i - 5]`在`dp[i - 3]`里面已经考虑过了，所以，对于j不必再拆分。

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        dp[2] = 1;
        for (int i = 3; i <= n; i ++) {
            for (int j = 1; j < i - 1; j ++) {
                dp[i] = Math.max(dp[i], j * (i - j));
                dp[i] = Math.max(dp[i], j * dp[i - j]);
            }
        }
        return dp[n];
    }
}
```

2、贪心

利用数学结论：

①若拆分的数量 a 确定， 则 **各拆分数字相等时** ，乘积最大。

②将数字 n 尽可能以因子 3 等分时，乘积最大。

拆分规则：
最优： 33 。把数字 nn 可能拆为多个因子 33 ，余数可能为 0,1,20,1,2 三种情况。
次优： 22 。若余数为 22 ；则保留，不再拆为 1+11+1 。
最差： 11 。若余数为 11 ；则应把一份 3 + 13+1 替换为 2 + 22+2，因为 2 \times 2 > 3 \times 12×2>3×1。

```java
class Solution {
    public int integerBreak(int n) {
        if(n <= 3) return n - 1;
        int a = n / 3, b = n % 3;
        if(b == 0) return (int)Math.pow(3, a);
        if(b == 1) return (int)Math.pow(3, a - 1) * 4;
        return (int)Math.pow(3, a) * 2;
    }
}
```



#### 3、不同的二叉搜索树

[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

`dp[i]`表示整数 i 的二叉树种树，则其总能保证左子树的节点个数从0-(i - 1)，右子树个数从(i - 1)-0（不考虑节点值，只考虑形状）。设左右子树的个数分别为n、m，左右子树的种类数，和`do[n]`、`dp[m]`是一样的(这里不必考虑每个节点上的值是否一致，我们只需考虑种数即可)，

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= i; j ++) {
                dp[i] += dp[j - 1] * dp[i - j]; //注意，这里需要减去根节点，总共考虑n-1个节点
            }
        }
        return dp[n];
    }
}
```



#### 4、分割等和子集

[分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

设定物体重量为数组元素的值，其对应的价值也为该元素的值。所以，对于某一个固定容量的背包，当其所放下最大重量时，其价值也最大，且最大价值和放入背包的重量是一样的。本题中，我们可以将背包重量设置为数组元素总和的一半，对应于01背包问题，当我们的背包装满时，如果其价值也是对应重量，说明，找到一个组合元素，使得其元素和为背包重量，即数组元素和的一半，如果其价值小于其价值，说明不存在这样的组合。(注意：若存在这样的组合，当背包容量为数组元素总和一半时，其价值必然也是数组元素总和一半的大小，当然，这种组合也可能不止一个)

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int i = 0; i < nums.length; i ++) {
            sum += nums[i];
        }
        if (sum % 2 == 1) return false;
        int target = sum / 2; //求数组元素总和的一半
        int[] dp = new int[target + 1]; //只需考虑背包容量最大为target即可
        for (int i = 0; i < nums.length; i ++) {
            for (int j = target; j >= nums[i]; j --) {
                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[target] == target;
    }
}
```



#### 5、最后一块石头的重量

[1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

假设所有石头的总重量为sum，当我们可以将所有石头分成两堆，每堆的重量分别为sum / 2时，最终结果肯定是最小的0，当我们的sum是奇数，不能均分成两堆时，则最后结果肯定不是0，这时，我们将其分成重量相差最小的两堆，即sum / 2和sum / 2 + 1，假设石头的价值和石头的重量一样时，和*分割等和子集一样*，当我们的背包被上最多重量的石头时，其价值最大。此时，若每堆石头的价值能分别达到sum / 2和sum / 2 + 1，这时，最后结果肯定是最小的1，但有时背包并不能全部装下石头，可能会有空闲空间，此时，也要尽可能减少两堆石头之间的差值，这样，最后的结果也就越小，对应到背包问题就是石头价值越大（此时第二堆对应的背包可能会超容，但没关系，我们关注第一个背包就好了，最终结果是要保证两个背包的价值差额最小）。

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int i : stones) sum += i;
        int target = sum >> 1;
        int[] dp = new int[target + 1];
        for (int i = 0; i < stones.length; i ++) {
            for (int j = target; j >= stones[i]; j --) {
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - 2 * dp[target];
    }
}
```



#### 6、目标和

[494. 目标和](h494. 目标和ttps://leetcode-cn.com/problems/target-sum/)

**对于01背包问题，一般将问题分成两部分来考虑**，这里，可以将整个数组分成`正数`和`负数`两部分，也就是`+`和`-`，将正数部分和记为left，负数部分和记为right，数组元素和记为sum，则`left - right = target`，而`right = sum - left`，则`2left = sum + target`，由此得`left = (sum + target) / 2`。则问题转化成01背包问题：从数组中选择子数组，其元素和为`(sum + target) / 2`，这样的子数组有多少种选法。`dp[i][j]`表示从0-i元素中选择，满足和为j的选法种数，利用滚动数组优化就是`dp[j]`，`dp[i][j]`由两部分组成：`dp[i - 1][j]`和`dp[i - 1][j - nums[i]]`，`dp[i - 1][j]`表示不选第i个元素时的选法种树，`dp[i - 1][j - nums[i]]`表示选第i个元素时的选法种树，`dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]]`，对应到一维数组就是`dp[j] += dp[j - nums[i]]`。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int i : nums) sum += i;
        if ((sum + target) % 2 != 0) return 0;
        if (Math.abs(target) > sum) return 0;
        int bagSize = (sum + target) / 2;
        int[] dp = new int[bagSize + 1];
        dp[0] = 1; //这里必须先初始化为1
        for (int i = 0; i < nums.length; i ++) {
            for (int j = bagSize; j >= nums[i]; j --) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
}
```



#### 7、一和零

[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

这里有两个约束：`最多有m个0和n个1`，所以，这里背包相当于是有两个。这种情况，其实也是和普通背包问题一样，只是最后考虑背包时需要两个循环来处理。

```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        //dp[i][j]表示i个0和j个1时的最大子集
        int[][] dp = new int[m + 1][n + 1];
        int oneNum, zeroNum;
        for (String str : strs) {
            oneNum = 0;
            zeroNum = 0;
            for (char ch : str.toCharArray()) {
                if (ch == '0') {
                    zeroNum++;
                } else {
                    oneNum++;
                }
            }
            //倒序遍历
            for (int i = m; i >= zeroNum; i--) {
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
}
```

注意：上述代码是经过空间复杂度优化后的算法，如果按照正常的做法应该是定义一个三维dp数组。



#### 8、完全背包问题中的组合数问题

[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

本题`dp[i][j]`表示考虑0-i个物品，其组合起来的值恰好为j的组合数。由完全背包问题分析可知：

`dp[i][j] = dp[i - 1][j] + dp[i - 1][j - coins[i]] + dp[i - 1][j - 2 * coins[i]] + ...`

同时：

`dp[i][j - coins[i]] = dp[i - 1][j - coins[i]] + dp[i - 1][j - 2 * coins[i]] + ...`（注意，这个`dp[i][j - coins[i]]`没有实际意义）

所以：

`dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]]`

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int i = 0; i < coins.length; i ++) {
            for (int j = coins[i]; j <= amount; j ++) {
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
}
```

注意这里的遍历顺序，这里只能是先遍历物品再遍历背包容量。

在求装满背包有几种方案的时候，认清遍历顺序是非常关键的。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。



#### 9、特殊的属性

[139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

1. 确定dp数组以及下标的含义

   dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。

2. 确定递推公式

   如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。

   所以递推公式是 if([j, i] 这个区间的子串出现在字典里 && dp[j]是true) 那么 dp[i] = true。

3. dp数组如何初始化

   从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了.

4. 确定遍历顺序

   此题先遍历背包再遍历物品会更好理解一些，但先遍历物品再遍历背包也是可以的，只是难理解且代码更麻烦一些。

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length() + 1];
        dp[0] = true;
        for (int i = 1; i <= s.length(); i ++) {
            for (int j = 0; j < i; j ++) {
                if (dp[j] && wordDict.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.length()];
    }
}
```



#### 10、打家劫舍

[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

这题是对打家劫舍的升级，其邻居围成一个圈，第一家和最后一家临近，只能考虑其中一家进行盗窃。这里可以将该圈分成两种情况来考虑：第一种考虑第一家；第二种考虑最后一家。然后分别对该两种情况使用打家劫舍的动态规划来进行考虑。

```java
class Solution {
    //打家劫舍问题
    private int robCommon(int[] nums, int left, int right) { //左闭右开
        if (right - left <= 1) return nums[left];
        int n = right - left;
        int[] dp = new int[n];
        dp[0] = nums[left];
        dp[1] = Math.max(dp[0], nums[left + 1]);
        for (int i = 2; i < n; i ++) {
            dp[i] = Math.max(dp[i - 2] + nums[left + i], dp[i - 1]);
        }
        return dp[n - 1];
    }
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        //分别考虑
        int result1 = robCommon(nums, 0, nums.length - 1);
        int result2 = robCommon(nums, 1, nums.length);
        return Math.max(result1, result2);
    }
}
```

这里我们发现，其实打家劫舍问题只和`dp[i - 1]`和`dp[i - 2]`有关，所以，我们可以使用三个变量来优化空间复杂度。**对于所有的动态规划问题，当只用到前几个dp数组元素时，都可以使用变量来优化空间复杂度**。

```java
class Solution {
    private int robCommon(int[] nums, int left, int right) { //左闭右开
        int pre = 0, cur = 0, tmp;
        for (int i = left; i < right; i ++) {
            tmp = cur;
            cur = Math.max(cur, pre + nums[i]);
            pre = tmp;
        }
        return cur;
    }
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];
        int result1 = robCommon(nums, 0, nums.length - 1);
        int result2 = robCommon(nums, 1, nums.length);
        return Math.max(result1, result2);
    }
}
```



#### 11、树形DP问题

[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

这道题考虑在树上做动态规划问题，对于每个父节点，考虑偷于不偷两种情况，当偷父节点时，就不再考虑两个子节点，当不偷父节点时，则考虑两个子节点（注意，这里并不是说不偷父节点就一定要偷其两个子节点，偷不偷两个子节点是一种考虑状态，需要比较来判断），这里的状态转移矩阵用dp[2]来表示，下标为0表示不偷该节点，下标为1表示偷该节点。

由于是树形结构，所以要结合二叉树的遍历三部曲和dp问题的五部曲来综合考虑。这里必须先考虑子节点的状态再来判断偷不偷父节点，所以必须使用后序遍历。

```java
class Solution {
    public int rob(TreeNode root) {
        int[] dp = robTree(root);
        return Math.max(dp[0], dp[1]);
    }
    private int[] robTree(TreeNode root) {
        int[] dp = new int[2];
        if (root == null) return dp;
        int[] leftTree = robTree(root.left);
        int[] rightTree = robTree(root.right);
        //偷root
        dp[1] = root.val + leftTree[0] + rightTree[0];
        //不偷root
        dp[0] = Math.max(leftTree[0], leftTree[1]) + Math.max(rightTree[0], rightTree[1]);
        return dp; 
    }
```

这里之所以要使用一个二维数组来表示，可以将其作为树形dp的做题标准，记住就行。

这道题还可以使用暴力递归+记录状态来做，使用Map来记录每个节点的状态，当遍历到的节点在Map中已经存在则直接返回。这样可以避免暴力遍历的超时问题。虽然事件负责度都是`O(0)`，但是其效果没有dp好。



#### 12、股票问题

[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

这道题目可以直接贪心做，考虑每一天，如果在该天抛出股票，那么最大收益肯定是从第一天开始到该天之间股票最小值时买入时收益最大，所以可以记录从0-i之间的最小买入值low，然后用prices[i] - low就是第i天抛出股票所获的最大收益。第0-i天抛出所获收益的最大值就是结果。

```java
//贪心
class Solution {
    public int maxProfit(int[] prices) {
        int low = Integer.MAX_VALUE;
        int res = 0;
        for (int i = 0; i < prices.length; i ++) {
            low = Math.min(low, prices[i]);
            res = Math.max(res, prices[i] - low);
        }
        return res;
    }
}
```

动态规划做法：

`dp[i][0]`表示第i天持有股票时的最大收益，`dp[i][1]`表示第i天抛出股票的最大收益，分析可知，`dp[i][0]`可由`dp[i-1][0]`和`-prices[i]`中的最大值得出(注意，这里不能是`dp[i - 1][1] - prices[i]`，因为股票只能进行一次买卖，到第i天可能已经经历过一次买卖了，`dp[i-1][1]`可能已经是买卖后的值)，`dp[i][1]`可由`dp[i-1][1]`和`dp[i-1][0] + prices[i]`得出，所以可以此来实现递归。

```java
//dp
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (prices == null || n == 0) return 0;
        int[][] dp = new int[n][2]; //dp[i][0]表示第i天持有股票,dp[i][1]表示第i天不持有股票
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; i ++) {
            dp[i][0] = Math.max(dp[i - 1][0], 0 - prices[i]); //注意这里不能是dp[i - 1][1] - prices[i]
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[n - 1][1];
    }
}
```

我们发现，`dp[i]`只和`dp[i - 1]`有关，所以，可以进一步实现空间优化：

```java
//dp空间复杂度优化
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (prices == null || n == 0) return 0;
        int[][] dp = new int[2][2]; 
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < n; i ++) {
            dp[1][0] = Math.max(dp[0][0], 0 - prices[i]);//注意这里只能是0 - prices[i]
            dp[1][1] = Math.max(dp[0][1], dp[0][0] + prices[i]);
            dp[0][0] = dp[1][0];
            dp[0][1] = dp[1][1];
        }
        return dp[0][1];
    }
}
```



[123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

这道题限制了买卖股票的次数，所以相对而言难度加大不少。可以定义一个`n × 5`维的一个数组`dp[n][5]`，其中`dp[i][0]`表示任何不做买卖；`dp[i][1]`表示第i天第一次买入最高收益；`dp[i][2]`表示第i天第一次抛出最高收益;`dp[i][3]`表示第i天第二次买入最高收益；`dp[i][4]`表示第i天第二次抛出最高收益。更多解析见代码。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int n = prices.length;
        int[][] dp = new int[n][5]; 
        //dp[i][0]表示任何不做买卖；dp[i][1]表示第i天第一次买入最高收益；dp[i][2]表示第i天第一次抛出最高收益；
        //dp[i][3]表示第i天第二次买入最高收益；dp[i][4]表示dii天第二次抛出最高收益
        dp[0][0] = 0;
        dp[0][1] -= prices[0];
        dp[0][2] = 0;
        dp[0][3] -= prices[0];//这里可以理解为第一天买入卖出后又买入
        dp[0][4] = 0;
        for (int i = 1; i < n; i ++) {
            dp[i][0] = dp[i - 1][0]; //所有的dp[i][0]其实都是0
            //这里用dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);更加形象表示第i天的第一次买入收益，但是既然dp[i][0]都是0，所以为了美观就无所谓了
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = Math.max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[n - 1][4];
    }
}
```

进一步空间优化：

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int n = prices.length;
        int[] dp = new int[5]; 
        dp[0] = 0;
        dp[1] -= prices[0];
        dp[2] = 0;
        dp[3] -= prices[0];
        dp[4] = 0;
        for (int i = 1; i < n; i ++) {
            dp[1] = Math.max(dp[1],  -prices[i]); 
            dp[2] = Math.max(dp[2], dp[1] + prices[i]);
            dp[3] = Math.max(dp[3], dp[2] - prices[i]);
            dp[4] = Math.max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
    }
}
```



[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

该题增加了一个冷冻期，所以状态增加了，可以考虑四种状态：`dp[i][0]`表示持有状态，`dp[i][1]`表示抛出状态且已过冷冻期，`dp[i][2]`表示抛出状态且当天抛出，`dp[i][3]`表示冷冻期。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        int n = prices.length;
        int[][] dp = new int[n][4];
        //dp[i][0]表示持有状态，dp[i][1]表示抛出状态且已过冷冻期
        //dp[i][2]表示抛出状态且当天抛出，dp[i][3]表示冷冻期
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;
        dp[0][3] = 0;
        for (int i = 1; i < n; i ++) {
            dp[i][0] = Math.max(dp[i - 1][0], Math.max(dp[i - 1][1] - prices[i], dp[i - 1][3] - prices[i]));
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return Math.max(dp[n - 1][1], Math.max(dp[n - 1][2], dp[n - 1][3]));
    }
}
```



#### 13、子序列系列

[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

该题定义的`dp[i][j]`表示考虑nums1数组的第i - 1个元素和nums2数组的第j - 1个元素，当`nums1[i - 1] == nums2[j - 1]`相等时，就对其进行加1操作，递归函数为：`dp[i][j] = dp[i - 1][j - 1] + 1`。

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int res = 0;
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    res = Math.max(res, dp[i][j]);
                }
            }
        }
        return res;
    }
}
```

这里可以使用滚动数组进行空间复杂度的优化，我们发现：在两层for循环内部，`dp[i][j] = dp[i - 1][j - 1] + 1`都是关于j的一个递归，所以，我们可以定义一个关于j的一维数组，对于下表i可以由上一层的直接赋值过来。注意，此时应该避免重复覆盖问题，所以第二层for循环时应该从后往前遍历。

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int res = 0;
        int[] dp = new int[m + 1];
        for (int i = 1; i <= n; i ++) {
            for (int j = m; j > 0; j --) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[j] = dp[j - 1] + 1;
                    res = Math.max(res, dp[j]);
                } else {
                    dp[j] = 0;
                }
            }
        }
        return res;
    }
}
```



[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

这道题不考虑连续性，`dp[i][j]`则表示考虑`text1[i - 1]`和`text2[j - 1]`这两个元素时的最长公共子序列，这时，可以分成两种情况，第一是当`text1[i - 1] == text2[j - 1]`，第二种是`text1[i - 1] != text2[j - 1]`，第一种情况下，直接`dp[i][j] = dp[i - 1][j - 1] + 1`，第二种情况，当`text1[i - 1] != text2[j - 1]`时，这时须考虑`dp[i][j - 1]`和`dp[i - 1][j]`的最大值作为`dp[i][j]`值。

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n = text1.length();
        int m = text2.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[n][m];
    }
}
```



[392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

这道题目可以直接暴力求解：遍历字符串t，定义一个s的指针（下标）指向开始位置，当发现t中的元素与t当前的元素相同，就给指针往后移一位，当发现指针指向最后一个元素的后一位时，说明匹配完s字符串了，这时输出true，否则输出false.

第二种方法是动态规划，这种方法效率虽然没有暴力高，但是也是一种解法，同时可以与上面的最长公共子序列形成对比学习：

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int n = s.length();
        int m = t.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = dp[i][j - 1]; //注意这里和最长公共子序列的区别
                }
            }
        }
        return dp[n][m] == n;
    }
}
```



[115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

这道题增加难度，要求匹配的个数，此时唯一的不同点在于当`s[i] == t[j]`时，`dp[i][j]`应该由两个部分来组成，即`dp[i - 1][j - 1] + dp[i - 1][j]`，`dp[i - 1][j - 1]`可以理解为使用`s[i]`来匹配`t[j]`，`dp[i - 1][j]`则表示不用`s[i]`来匹配`t[j]`，而是从前`i - 1`个元素中选择一个来匹配`t[j]`，当然，可能匹配不上，则这时`dp[i - 1][j]`就为0了。

```java
class Solution {
    public int numDistinct(String s, String t) {
        int n = s.length(), m = t.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i <= n; i ++) dp[i][0] = 1;
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (s.charAt(i - 1) == t.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; //注意这一步
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[n][m];
    }
}
```



[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

这道题目有两个思路：

首先，我们可以转换为求两个字符串的最长子序列，然后用两个字符串的长度减去两倍最长子序列的长度即是答案。

第二种思路就是直接计算删除操作，`dp[i][j]`表示考虑字符串1的前i个元素和字符串2的前j个元素，其最小的删除操作。当`word1[i] == word2[j]`时，则不进行任何删除操作，即`dp[i][j] = dp[i - 1][j - 1]`，当`word1[i] != word2[j]`，则有三种可能性：第一，删除`word1[i]`和`word2[j]`，第二，删除`word1[i]`，第三，删除`word2[j]`，然后取其中的最小值。

```java
//思路一
class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length(), m = word2.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j -1]);
                }
            }
        }
        return (m + n - 2 * dp[n][m]);
    }
}
```

```java
//思路二
class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length(), m = word2.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i <= n; i ++) dp[i][0] = i;
        for (int j = 0; j <= m; j ++) dp[0][j] = j;
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i - 1][j - 1]+ 2,
                    Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));
                }
            }
        }
        return dp[n][m];
    }
}
```



[72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

这里`dp[i][j]`表示考虑word1的前i - 1个元素以及word2的前j - 1个元素，所需要操作的最小步骤。当`word1[i] == word2[j]`时，此时不需要做任何操作，当`word1[i] != word2[j]`时，此时，有三种操作，分别是增、删、改。对于增操作，我们可以理解为`dp[i - 1][j] + 1`，**对于删操作，我们可以理解为word2的增操作**，即`dp[i][j - 1] + 1`，对于改操作，可以表示成`dp[i - 1][j - 1] + 1`。

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length(), m = word2.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i <= n; i ++) dp[i][0] = i;
        for (int j = 0; j <= m; j ++) dp[0][j] = j;
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(dp[i][j - 1], Math.min(dp[i - 1][j], dp[i - 1][j - 1])) + 1;
                }
            }
        }
        return dp[n][m];
    }
}
```



#### 14、回文子串

[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

这道题可以使用动态规划或者双指针算法来做。

动态规划：`dp[i][j]`表示字符串s的第i-j个元素组成的子串是否为回文子串，是的话就是true，否则false。遍历字符串，我们有两种情况，第一是`s[i] != s[j]`，这时肯定`dp[i][j]`为false，其不是回文子串，第二种情况，`s[i] == s[j]`时，这时，如果i-j之间只有一个或者两个元素，则其肯定是回文子串，当i-j之间的元素大于2个时，就得看`dp[i + 1][j - 1]`的值了。

![647.回文子串](https://camo.githubusercontent.com/9cb222226e85be9b2772d59cbb1c7e1e0f3d263baf96134b8c0661008b56952c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303132313137313033323437332e6a7067)

注意，这里由于`dp[i][j]`要用到`dp[i + 1][j - 1]`,所以i需要从后往前，或者先遍历j。目的就是得先求出`dp[i + 1][j - 1]`。

```java
class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        int ans = 0;
        boolean[][] dp = new boolean[n][n];
        for (int i = n - 1; i >= 0; i --) {
            for (int j = i; j < n; j ++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j - i <= 1) {
                        ans ++;
                        dp[i][j] = true;
                    } else {
                        if (dp[i + 1][j - 1]) {
                            ans ++;
                            dp[i][j] = true;
                        }
                    }
                }
            }
        }
        return ans;
    }
}
```

双指针算法：我们可以基于一个元素或者两个元素，然后向外延申来判断是否回文子串。

```java
class Solution {
    public int countSubstrings(String s) {
        int res = 0;
        int n = s.length();
        for (int i = 0; i < n; i ++) {
            res += extend(s, i, i, n);
            res += extend(s, i, i + 1, n);
        }
        return res;
    }
    private int extend(String s, int i, int j, int n) {
        int cnt = 0;
        while (i >= 0 && j < n && s.charAt(i) == s.charAt(j)) {
            cnt ++;
            i --;
            j ++;
        }
        return cnt;
    }
}
```



[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

这里求回文子序列，可以定义`dp[i][j]`表示字符串i-j之间的子串的最长回文子序列，当`s[i] ==  s[j]`时，`dp[i][j] = dp[i + 1][j - 1] + 2`，当`s[i] != s[j]`时，此时可以比较`dp[i + 1][j]`和`dp[i][j - 1]`的最大值作为`dp[i][j]`的值。注意，初始化时需将`dp[i][i]`赋值为1，同时遍历时，j必须从i + 1开始遍历，同时，由于`dp[i][j]`要用到`dp[i + 1][j - 1]`，所以遍历顺序要注意。

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i ++) dp[i][i] = 1;
        for (int i = n - 1; i >= 0; i --) {
            for (int j = i + 1; j < n; j ++) { //注意这里要是j = i + 1，因为j = i在初始化时已经赋值
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
}
```



#### 15、n个骰子的点数

[剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

n个骰子的点数和分布在n~6*n之间，也就是有5n + 1个取值，先考虑第i-1个骰子和第i个骰子之间的关系，不妨设第i-1个骰子点数分布的概率用数组表示为dp[5 * (i - 1) + 1]，注意，这里dp的下标和骰子的点数和并不是一一对应，而是前移了。再考虑第i个骰子，其有六种取值，1、2、3、4、5、6，当取每一个值时，概率都为1 / 6，且取每个值时，该i个骰子的和为前i - 1个骰子点数和加上该骰子的点数，这样第i-1个dp数组就第i个dp数组联系起来了。

```java
class Solution {
    public double[] dicesProbability(int n) {
        double[] dp = new double[6];
        Arrays.fill(dp, 1 / 6.0);
        for (int i = 2; i <= n; i ++) {
            double[] tmp = new double[5 * i + 1];
            for (int k = 0; k < dp.length; k ++) {
                for (int m = 0; m < 6; m ++) {
                    tmp[k + m] += dp[k] / 6.0;
                }
            }
            dp = tmp;
        }
        return dp;
    }
}
```



#### 16、数字翻译成字符串的种类数

[剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

考虑前i个数字的字符串种类数，不妨记为f(i)，当最后两个数字能够翻译成字符串，也就是在10到25之间，则可以将最后两个数组组合以及不组和，对应的就是f(i - 2) 和 f(i - 1)，即f(i) = f(i - 1) + f(i - 2)。当最后两个数字不能翻译成字符串，则f(i) = f(i - 1)。其递归方程已经得出，只需考虑初始值等。设dp[i]表示前i个数字所能转换成的字符串种类数，易知dp[1] = 1，当i = 1时，没有最后两个数字，则肯定dp[1] = dp[0]，故dp[0] = 1。

```java
class Solution {
    public int translateNum(int num) {
        String str = String.valueOf(num);
        int[] dp = new int[str.length() + 1];\
        //初始化
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 1; i < str.length(); i ++) {
            String tmp = str.substring(i - 1, i + 1);
            //tmp.charAt(0) != '0'用来判断排除01、05这种情况
            if (tmp.charAt(0) != '0' && Integer.parseInt(tmp) >= 0 && Integer.parseInt(tmp) <= 25) {
                dp[i + 1] = dp[i] + dp[i - 1];
            } else {
                dp[i + 1] = dp[i];
            }
        }
        return dp[str.length()];
    }
}
```

空间优化：

```java
class Solution {
    public int translateNum(int num) {
        String str = String.valueOf(num);
        int a = 1;
        int b = 1;
        for (int i = 1; i < str.length(); i ++) {
            String cur = str.substring(i - 1, i + 1);
            if (cur.charAt(0) != '0' && Integer.parseInt(cur) >= 0 && Integer.parseInt(cur) <= 25) {
                int tmp = b;
                b = b + a;
                a = tmp; //一定要更新a，因为在dp中，i是不断前移的
            } else {
                a = b;
            }
        }
        return b;
    }
}
```



#### 17、正则表达式

[剑指 Offer 19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

`dp[i][j]`表示s字符串前i个字符和p字符串的前j个字符是否匹配

1、`p[j - 1] == '*'`

此时满足下列任一条件时，`dp[i][j] = true`

- `dp[i][j - 2] = true`，如”a" 和 “ab*”
- `dp[i - 1][j] == true && s[i - 1] == p[j - 2]`，如”abbb“ 和 “ab*”，这里之所以是`dp[i - 1][j] == true`，可以理解为`*`使其前一个元素可以有任意次，当s为"abbb"和“abbbb”时，都是可以与`“ab*”`匹配的。
- `dp[i - 1][j] == true && p[j - 2] == '.'`，如“abbb” 和 “a.*”

2、`p[j - 1] != '*'`

满足下列任一条件时，`dp[i][j] = true`

- `dp[i - 1][j - 1] == true && s[i - 1] == p[j - 1]`，如“ab” 和 “ab”
- `dp[i - 1][j - 1] == true && p[j - 1] == ''`，如 “ab” 和 “a.”

注意事项：

- 将dp定义成`dp[s.length() + 1][p.length() + 1]`，`dp[i][j]`下标表示s字符串前i个字符和p字符串的前j个字符是否匹配
- `dp[0][0]`应该为true
- 对于p，像`“a*”`、`“a*b*”`、`"a*b*c*"`...等，当s为空时，它们应该是匹配的，所以初始化时需要考虑

题解：

```
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        dp[0][0] = true;

        for (int j = 2; j <= p.length(); j += 2) {
            dp[0][j] = dp[0][j - 2] && p.charAt(j - 1) == '*';
        }
        for (int i = 1; i <= s.length(); i ++) {
            for (int j = 1; j <= p.length(); j ++) { //由题意，*不可能是第一个元素，所以j = 1时不会进入第一个分支
                if (p.charAt(j - 1) == '*') {
                    if (dp[i][j - 2]) {
                        dp[i][j] = true;
                    } else if (dp[i - 1][j] && s.charAt(i - 1) == p.charAt(j - 2)) {
                        dp[i][j] = true;
                    } else if (dp[i - 1][j] && p.charAt(j - 2) == '.') {
                        dp[i][j] = true;
                    }
                } else {
                    if (dp[i - 1][j - 1] && s.charAt(i - 1) == p.charAt(j - 1)) {
                        dp[i][j] = true;
                    } else if (dp[i - 1][j - 1] && p.charAt(j - 1) == '.') {
                        dp[i][j] = true;
                    }
                }
            }
        }
        return dp[s.length()][p.length()];
    }
}
```



## 三、排序算法



![](E:/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9B%BE%E5%BA%93/20181213135823283.jpg)

1、稳定的排序算法：归并排序、冒泡排序、插入排序和基数排序。

2、不是稳定的排序算法：快速排序、选择排序、希尔排序、堆排序。



#### 1、快速排序

![](https://i.loli.net/2021/05/12/T5kP2seMyZKz1mx.png)

```java
	private static void quicksort(int[] arr, int l, int r) {//l为数组第一个元素下标，r为数组最后一个元素下标
        if (l >= r) return;
        int i = l - 1, j = r + 1, x = arr[i + j >> 1];
        while (i < j) {
            do i ++; while (arr[i] < x); //不能等于
            do j --; while (arr[j] > x); //不能等于
            if (i < j) {
                int tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
        quicksort(arr, l, j);
        quicksort(arr, j + 1, r);
    }
```

#### 2、归并排序

![](https://i.loli.net/2021/05/12/uTXhMliCtpONgHD.png)

```java
    private static void mergesort(int[] arr, int l, int r) {
        if (l >= r) return;
        int mid = l + r >> 1;
        mergesort(arr, l, mid);
        mergesort(arr, mid + 1, r);
        int k = 0, i = l, j = mid + 1;
        int[] tmp = new int[r - l + 1];
        while (i <= mid && j <= r) {
            if (arr[i] <= arr[j]) tmp[k ++] = arr[i ++];
            else tmp[k ++] = arr[j ++];
        }
        while (i <= mid) tmp[k ++] = arr[i ++];
        while (j <= r) tmp[k ++] = arr[j ++];
        for (i = l, j = 0; i <= r; i ++, j ++) arr[i] = tmp[j]; //注意，这里的i必须是l，j必须是0
    }
```



##### 1、归并排序与逆序对关系





##  四、双指针算法



### 1、双指针的应用

双指针法就是通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作,	快指针走在前面，其所遍历的数组是原始数组。

![](https://i.loli.net/2021/09/19/h1kR7l6inMK8ZSj.gif)

例题：27.移除元素

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) { //关键所在，太优美了
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

使用双指针法有两个注意点：

- 只需在外面定义慢指针，快指针在for循环里定义
- 注意if语句的用法，写得太好了

**STL中unique()函数的底层实现原理：**

```c++
vector<int>::iterator unique(vector<int> &a)
{
    int j = 0;
    for (int i = 0; i < a.size(); i ++ )
        if (!i || a[i] != a[i - 1])
            a[j ++ ] = a[i];
    // a[0] ~ a[j - 1] 所有a中不重复的数

    return a.begin() + j;
}
```

这也是一个双指针，而且没有额外的内存消耗，因为i总是会大于等于j，所以可以直接在原数组上进行操作。



双指针算法有快慢指针、左右指针、双数组指针等。



### 2、滑动窗口

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。其也是双指针的一种，只是其操作过程更像一个窗口滑动一般，所以叫滑动窗口更合适。

滑动窗口主要处理以下三个点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

例题：209.长度最小的子数组

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int start = 0, end = 0, sum = 0, n = nums.size(), ans = 100010;
        while (end < n) {
            sum += nums[end];
            while (sum >= target) {
                ans = min (ans, end - start + 1);
                sum -= nums[start++];
            }
            end++;
        }
        return ans == 100010 ? 0 : ans;
    }
};
```

模板：

```
for(枚举选择)
    右边界
    while(不符合条件)
        左边界
    更新结果
```



### 3、题目集合

#### 1、删除链表倒数第n个节点

[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

定义一个哑节点可以有效地简洁代码，这里利用快慢指针，可以有效解决问题， 注意一个问题，由于定义了一个哑节点，所以快指针需要比满节点提前n + 1步。

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if (head == null) return null;
        ListNode dummy = new ListNode(); //定义哑节点
        dummy.next = head;
        ListNode slow = dummy, fast = dummy;
        while (n > 0) {
            fast = fast.next;
            n --;
        }
        fast = fast.next; //再往前走一步
        while (fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```



#### 2、判断环形链表

[141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

这道题目可以直接利用一个哈希表，判断遍历的节点在之前是否有出现过，若出现过则返回true，否则返回false。

这里还可以有个更好的思路，就是利用双指针算法，定义快慢指针，慢指针每次走一步，快指针每次走两步，如果有环存在的话，那快慢指针必然会遇上。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null) return false;
        ListNode slow = head, fast = head.next;
        while (fast != null) {
            if (fast == slow) return true;
            fast = fast.next;
            slow = slow.next;
            if (fast != null) fast = fast.next;
        }
        return false;
    }
}
```



#### 3、求环的入口节点

[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

解析见[链接](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.md)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) return null;
        ListNode slow = head, fast = head; //注意快慢指针都是从head开始
        while (fast != null && fast.next != null) {
            slow = slow.next; //慢指针每次走一步
            fast = fast.next.next; //快指针每次走两步
            if (slow == fast) { //相遇，表示有环
                ListNode nodeA = head;
                ListNode nodeB = fast;
                while (nodeA != nodeB) {
                    nodeA = nodeA.next;
                    nodeB = nodeB.next;
                }
                return nodeA;
            }
        }
        return null;
    }
}
```



#### 3.1、寻找重复数

[287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

首先明确前提，整数的数组 nums 中的数字范围是 [1,n]。

如果数组中有重复的数，以数组 [1,3,4,2,2] 为例,我们将数组下标 n 和数 nums[n] 建立一个映射关系 f(n)，
其映射关系 n->f(n) 为：
0->1
1->3
2->4
3->2
4->2
我们从下标为 0 出发，根据 f(n) 计算出一个值，以这个值为新的下标，再用这个函数计算，以此类推产生一个类似链表一样的序列。
0->1->3->2->4->2->4->2->……
这里 2->4 是一个循环，那么这个链表可以抽象为下图：

![](https://pic.leetcode-cn.com/999e055b41e499d9ac704abada4a1b8e6697374fdfedc17d06b0e8aa10a8f8f6-287.png)


从理论上讲，数组中如果有重复的数，那么就会产生多对一的映射，这样，形成的链表就一定会有环路了，

综上
1.数组中有一个重复的整数 <==> 链表中存在环
2.找到数组中的重复整数 <==> 找到链表的环入口

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int fast = 0, slow = 0;
        fast = nums[nums[fast]];
        slow = nums[slow];
        while (fast != slow) {
            fast = nums[nums[fast]];
            slow = nums[slow];
        }
        int idx1 = 0, idx2 = fast;
        while (idx1 != idx2) {
            idx1 = nums[idx1];
            idx2 = nums[idx2];
        }
        return idx1;
    }
}
```



#### 4、三数之和

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

这里注意两种情况：第一是[-4,-1,-1,-1,-2]中，第一个元素的去重方法不对的话会丢失[-1，-1，2]这种情况；第二，第二三个元素的去重位置不对时，会丢失[0,0,0]这种情况。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        if (nums == null || nums.length < 3) return result;
        Arrays.sort(nums);

        for (int i = 0; i < nums.length; i ++) {
            if (nums[i] > 0) return result; //当nums[i]大于0时，其后两个数字必大于0
            // 错误去重方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重方法
            if (i > 0 && nums[i] == nums[i - 1]) continue; //第一个元素去重
            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                */
                int sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) {
                    right --;
                } else if (sum < 0) {
                    left ++;
                } else {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    //第二个元素去重
                    while (left < right && nums[left] == nums[left + 1]) left ++;
                    //第三个元素去重
                    while (left < right && nums[right] == nums[right - 1]) right --;
                    // 找到答案时，双指针同时收缩
                    left ++;
                    right --;
                }
            }
        }
        return result;
    }
}
```



#### 5、接雨水

[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

定义两个指针分别指向数组左右两个下标，每次都从左右两端小的那一端开始考虑，因为大的那一端已经保证了该方向的值是大于相反方向的值，所以该下标所能接的雨水量和小的那一端的值有关。同时，我们还需要维护两个值：leftMax和rightMax，当我们从左端开始遍历时，如果当下的值大于等于leftMax，那该下标肯定是不能存储雨水的，我们只要处理更新leftMax的逻辑即可；当我们从右端开始遍历时，如果当下的值大于等于rightMax，那该下标肯定时不能存储雨水的，我们只要处理更新rightMax的逻辑即可。

```java
class Solution {
    public int trap(int[] height) {
        if (height.length <= 2) return 0;
        int leftMax = 0, rightMax = 0; //维护左右两边的做大高度
        int left = 0, right = height.length - 1; //定义双指针
        int res = 0; //存储最终结果
        while (left < right) {
            if (height[left] < height[right]) { //当左端值小于右端值，则从左端开始遍历
                if (height[left] >= leftMax) { //如果当前值大于leftMax。只需做更新leftMax的逻辑
                    leftMax = height[left];
                } else { //否则收集雨水
                    res += leftMax - height[left];
                }
                left ++;
            } else {
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    res += rightMax - height[right];
                }
                right --;
            }
        }
        return res;
    }
}
```



## 五、回溯算法



### 1、回溯算法模板

**回溯法解决的问题都可以抽象为树形结构！**

回溯三部曲：

1. **回溯函数模板返回值以及参数**

   - 回溯算法中函数返回值一般为void。

   - 对于参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

   ```
   void backtracking(参数) //回溯函数伪代码
   ```

2. **回溯函数终止条件**

   什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

   ```
   if (终止条件) {
       存放结果;
       return;
   } //终止条件伪代码
   ```

3. **回溯搜索的遍历过程**

![](https://camo.githubusercontent.com/f65ca647f31913496481cd1aff144040bd7ee4f6bc30accd370bc78b4b265d13/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303133303137333633313137342e706e67)

回溯算法模板伪代码：

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

**注意事项：**

1、是否先让容器有序；

2、重复时，是用continue还是return；



### 2、题目集合

#### 1、组合问题

[77. 组合](https://leetcode-cn.com/problems/combinations/)

![](https://camo.githubusercontent.com/33d520a983f316935dd6b5bc3401160705c0a5050ce9feaf4e2a1a2d8db40799/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313132333139353234323839392e706e67)

同时，可以考虑用剪枝来进行优化：

![](https://camo.githubusercontent.com/1d9148107548d853ba1f58b0507cb85835dc4aed5be588e21f280458b63b05b3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303133303139343333353230372e706e67)

解答：

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> combine(int n, int k) {
        res.clear();
        path.clear();
        combineHelper(n, k, 1);
        return res;
    }

    private void combineHelper(int n, int k, int startIndex) {
        //终止条件
        if (path.size() == k) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i ++) { //引入剪枝优化
            path.add(i);
            combineHelper(n, k, i + 1);
            path.removeLast();
        }
    }
}
```



[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

这里没有数量要求，所以，通过终止条件来判断递归的深度。

同时，该题的元素可以重复运用，但为了最终结果的唯一性，还是要带上startIndex这个参数。例如`[2,3,5]`中，如果求target是7。如果没有startIndex参数，那么每次都是从0下标开始遍历，那会出现`[2,2,3]`和`[2,3,2]`这种相同的结果，但`[2,3,2]`这一结果其实在之前已经遍历过了。如果带上startIndex，那么每次都是从当前index开始遍历，就不会有重复的结果产生。

```java
class Solution {
    private List<List<Integer>> result = new ArrayList<>(); //存储最终结果
    private ArrayList<Integer> sublist = new ArrayList<>(); //存储每个符合要求的组合

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates); //将数组先排好序
        backtracking(candidates, target, 0, 0);
        return result;
    }

    private void backtracking(int[] candidates, int target, int sum, int startIndex) {
        if (sum > target) {
            return;
        } else if (sum == target) {
            result.add(new ArrayList<>(sublist));
            return;
        }
        for (int i = startIndex; i < candidates.length; i ++) { //每次从startIndex开始
            sum += candidates[i];
            sublist.add(candidates[i]);
            backtracking(candidates, target, sum, i); //注意，由于元素可重复利用，所以i不用加1
            sum -= candidates[i];
            sublist.remove(sublist.size() - 1);
        }
    }
}
```



[40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

这题规定，组合内部可以重复元素，但是解集中不能有重复。这里需要理解两个去重的维度：一个是同一树枝上使用过；一个是同一树层上使用过。例如`[1,1,1,2]`，target为3，则组合`[1,1,1]`就是指树枝上的重复，而`[1,2]`和`[1,2]`（注意，这里的两个1对应到原数组上是不同的下标）就是数层上的重复。

这题允许树枝上的重复，不允许数层上的重复，所以我们需要引入一个判断。这里增加这个数层重复的判断，可以很好理解，因为后面的情况在前面已经考虑过了，比如前面的例子`[1,1,1,2]`，我们在考虑第一个1时，就已经有了`[1,2]`这种情况判断了。如果还考虑后面两个1的话，就会造成重复。

```java
class Solution {
    private List<List<Integer>> result = new ArrayList<>();
    private ArrayList<Integer> path = new ArrayList<>();

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        backtracking(candidates, target, 0, 0);
        return result;
    }

    private void backtracking(int[] candidates, int target, int sum, int startIndex) {
        if (sum > target) {
            return;
        } else if (sum == target) {
            result.add(new ArrayList<>(path));
            return;
        }

        for (int i = startIndex; i < candidates.length; i ++) {
            if (i > startIndex && candidates[i] == candidates[i - 1]) continue; //增加数层重复一个判断,必须是i > startIndex，如果是大于0的话，则会导致树枝重复也会过滤掉
            sum += candidates[i];
            path.add(candidates[i]);
            backtracking(candidates, target, sum, i + 1);
            sum -= candidates[i];
            path.remove(path.size() - 1);
        }
    }
}
```

**注意：`List<List<Integer>> result`在添加元素时，必须是`result.add(new ArrayList<>(path));`**



#### 2、电话号码字母组合

[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

本题先要存储数字与字符串的映射关系，可以使用哈希表，也可以使用字符串数组来实现。

```java
class Solution {
    private List<String> res = new ArrayList<>(); //存储最终结果
    private StringBuilder sb = new StringBuilder(); //存储每次的遍历结果
    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) return new ArrayList<>();
        //定义数字和字符串的映射关系
        String[] mapping = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        backtracking(digits, mapping, 0);
        return res;
    }
    //回溯算法
    private void backtracking(String digits, String[] mapping, int num) {
        //终止条件
        if (num == digits.length()) {
            res.add(sb.toString());
            return;
        }
        //求取每层的字符串
        String tmp = mapping[digits.charAt(num) - '0'];
        for (int i = 0; i < tmp.length(); i ++) {
            sb.append(tmp.charAt(i));
            backtracking(digits, mapping, num + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}
```



#### 3、分割回文串

[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

本题有两个难点：一个是如何切割；另一个是判断回文串。

因为字符串中的每个字符都用到了，所以，可以按照第一个字符做一个字符串、前两个字符做一个字符串...所有字符作为一个字符串来切割，这样就可以对应到组合问题上。

判断回文串直接使用双向指针即可。

```java
class Solution {
    private List<List<String>> result = new ArrayList<>();
    private List<String> path = new ArrayList<>();

    public List<List<String>> partition(String s) {
        backtracking(s, 0);
        return result;
    }

    private void backtracking(String s, int startIndex) {
        if (startIndex >= s.length()) { //遍历到字符串最后位置，则保存结果
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = startIndex; i < s.length(); i ++) {
            if (!isPalindrom(s, startIndex, i)) continue; //不是回文串，直接进入下一个循环
            path.add(s.substring(startIndex, i + 1));
            backtracking(s, i + 1);
            path.remove(path.size() - 1);
        }
    }

    private boolean isPalindrom(String str, int startIndex, int endIndex) {
        for (int i = startIndex, j = endIndex; i < j; i ++, j --) {
            if (str.charAt(i) != str.charAt(j)) return false;
        }
        return true;
    }
}
```



#### 4、递增子序列

[491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)

本题有一个问题，就是需要在同一层做去重，但是又不能排序改变原数组的顺序，那么该怎么办呢？

一个好的解决办法就是引入一个哈希表，用来记录之前使用过的元素，当发现同一层中之前使用过了，那么就直接continue。但是，这里还有一个问题，就是我们的哈希表只能是记录该层用过的元素，而不能定义成全局的变量，如果定义成全局变量的话，那么将会导致树枝上也去重。所以这里将哈希表定义为backtracking函数的局部变量，在下一层遍历时，会创建新的哈希表从而覆盖之前的哈希表，从而实现了在同一层中的去重。

```java
class Solution {
    private List<List<Integer>> result = new ArrayList<>();
    private List<Integer> path = new ArrayList<>();
    

    public List<List<Integer>> findSubsequences(int[] nums) {
        backtracking(nums, 0);
        return result;
    }

    private void backtracking(int[] nums, int startIndex) {
        if (path.size() > 1) {
            result.add(new ArrayList<>(path));
        }
        if (startIndex > nums.length) return;
        //该set只能作为backtracking的局部变量，不能定义为全局变量
        Set<Integer> set = new HashSet<>(); //存储前面出现过的元素

        for (int i = startIndex; i < nums.length; i ++) {
            if (i > startIndex && set.contains(nums[i])) {
                continue;
            }
            if (!path.isEmpty() && nums[i] < path.get(path.size() - 1)) {
                continue;
            }
            set.add(nums[i]);
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```



#### 5、排列问题

[46. 全排列](https://leetcode-cn.com/problems/permutations/)

排列问题需要考虑顺序，所以可以不需要startIndex，但是需要一个数组来记录之前遍历过的元素。

```java
class Solution {
    private List<List<Integer>> result = new ArrayList<>();
    private List<Integer> path = new ArrayList<>();
    private boolean[] flag = new boolean[21];

    public List<List<Integer>> permute(int[] nums) {
        backtracking(nums, flag);
        return result;
    }

    private void backtracking(int[] nums, boolean[] flag) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i ++) {
            if (flag[nums[i] + 10]) continue;
            flag[nums[i] + 10] = true;
            path.add(nums[i]);
            backtracking(nums, flag);
            flag[nums[i] + 10] = false;
            path.remove(path.size() - 1);
        }
    }
}
```



[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

该题的难点就是如何进程同一层的去重，这里给出一个很好的解决办法，见代码注释。

```java
class Solution {
    private List<List<Integer>> result = new ArrayList<>();
    private List<Integer> path = new ArrayList<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        boolean[] flag = new boolean[nums.length]; //定义数组表示使用过的元素
        backtracking(nums, flag);
        return result;
    }

    private void backtracking(int[] nums, boolean[] flag) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i ++) {
            //当nums[i] == nums[i - 1]并且第i-1个元素未使用，说明该层该元素已经用过了
            if (i > 0 && nums[i] == nums[i - 1] && !flag[i - 1]) continue; 
            if (!flag[i]) {
                path.add(nums[i]);
                flag[i] = true;
                backtracking(nums, flag);
                path.remove(path.size() - 1);
                flag[i] = false;
            }
        }
    }
}
```



#### 6、待补充

《代码随想录》19、20、21



## 六、贪心算法



### 1、贪心判据



**如果找到局部最优，然后推出整体最优，那么就是贪心。**



### 2、题目集和



#### 1、摆动序列

[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

![](https://camo.githubusercontent.com/602161d41b06ef9b2a3b1651b28cbb107078d2ba55aae0a285269ec1a53e4335/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313132343137343332373539372e706e67)

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        if (nums.length <= 1) {
            return nums.length;
        }
        //当前差值
        int curDiff = 0;
        //上一个差值
        int preDiff = 0;
        int count = 1;
        for (int i = 1; i < nums.length; i++) {
            //得到当前差值
            curDiff = nums[i] - nums[i - 1];
            //如果当前差值和上一个差值为一正一负
            //等于0的情况表示初始时的preDiff
            if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
                count++;
                preDiff = curDiff;
            }
        }
        return count;
    }
}
```

还可以动态规划：

```java
// DP
class Solution {
    public int wiggleMaxLength(int[] nums) {
        // 0 i 作为波峰的最大长度
        // 1 i 作为波谷的最大长度
        int dp[][] = new int[nums.length][2];

        dp[0][0] = dp[0][1] = 1;
        for (int i = 1; i < nums.length; i++){
            //i 自己可以成为波峰或者波谷
            dp[i][0] = dp[i][1] = 1;

            for (int j = 0; j < i; j++){
                if (nums[j] > nums[i]){
                    // i 是波谷
                    dp[i][1] = Math.max(dp[i][1], dp[j][0] + 1);
                }
                if (nums[j] < nums[i]){
                    // i 是波峰
                    dp[i][0] = Math.max(dp[i][0], dp[j][1] + 1);
                }
            }
        }

        return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);
    }
}
```



#### 2、最大子数组和

[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int result = Integer.MIN_VALUE;
        int count = 0;
        for (int i = 0; i < nums.length; i ++) {
            count += nums[i];
            if (count > result) result = count; //取区间累计的最大值
            if (count < 0) count = 0; //相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
        }
        return result;
    }
}
```



#### 3、买卖股票的最佳时期

[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

该题可以将买卖股票的时间段分成一天天来考虑，每天利润可以理解为前一天买入当天卖出的收获。这样，要是全局最优的话就是做到每天的利润都是正数即可。

![](https://camo.githubusercontent.com/825edddc6288b4e013521cc3670e931c31704dfbd0c99b4e522514362506bb79/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f323032303131323931373438303835382e706e67)

```java
// 贪心思路
class Solution {
    public int maxProfit(int[] prices) {
        int result = 0;
        for (int i = 1; i < prices.length; i++) {
            result += Math.max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
}
```



#### 4、跳跃游戏

[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。

```java
class Solution {
    public boolean canJump(int[] nums) {
        if (nums.length == 1) return true;
        int cover = 0;
        for (int i = 0; i <= cover; i ++) { //注意这里必须是小于cover
            cover = Math.max(cover, i + nums[i]);
            if (cover >= nums.length - 1) return true;
        }
        
        return false;
    }
}
```

[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

该题需要求最小跳跃次数，所以我们考虑每次跳跃让其覆盖范围达到最大。当我们最大覆盖范围超过队尾后就退出，当还没到队尾，但是遍历到当前最大覆盖范围的最后时，让我们的跳跃次数变量加一，表示还需要再跳一次。这样，每次都是局部最优，最后得到全局最优。

```java
class Solution {
    public int jump(int[] nums) {
        if (nums == null || nums.length == 0 || nums.length == 1) {
            return 0;
        }
        //记录跳跃的次数
        int count=0;
        //当前的覆盖最大区域
        int curDistance = 0;
        //最大的覆盖区域
        int maxDistance = 0;
        for (int i = 0; i < nums.length; i++) {
            //在可覆盖区域内更新最大的覆盖区域
            maxDistance = Math.max(maxDistance,i+nums[i]);
            //说明当前一步，再跳一步就到达了末尾
            if (maxDistance>=nums.length-1){
                count++;
                break;
            }
            //走到当前覆盖的最大区域时，更新下一步可达的最大区域
            if (i==curDistance){
                curDistance = maxDistance;
                count++;
            }
        }
        return count;
    }
}
```



#### 5、加油站

[134. 加油站](https://leetcode-cn.com/problems/gas-station/)

![](E:/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9B%BE%E5%BA%93/333.png)

如上图所示，这道题先求出left[] = gas[] - cost[]，要想绕一圈，那么最终的剩余油量肯定是不小于0的，然后，我们可以将小区间合并成大区间，只要碰到和为负的区间就合并作为一个大的区间，如上，可以将5段区间合并成三段区间，前两段都是负的，又最终结果是非负的，所以最后这段肯定会是正的，从最后这段正区间的起点出发，肯定可以绕一圈。

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int curSum = 0;
        int totalSum = 0;
        int index = 0;
        for (int i = 0; i < gas.length; i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {
                index = (i + 1) % gas.length ; 
                curSum = 0;
            }
        }
        if (totalSum < 0) return -1;
        return index;
    }
}
```



#### 6、分发糖果

[135. 分发糖果](https://leetcode-cn.com/problems/candy/)

```java
class Solution {
    /** 
         分两个阶段 
         1、起点下标1 从左往右，只要 右边 比 左边 大，右边的糖果=左边 + 1
         2、起点下标 ratings.length - 2 从右往左， 只要左边 比 右边 大，此时 左边的糖果应该 取本身的糖果数（符合比它左边大） 和 右边糖果数 + 1 二者的最大值，这样才符合 它比它左边的大，也比它右边大
    */
    public int candy(int[] ratings) {
        int[] candyVec = new int[ratings.length];
        candyVec[0] = 1;
        for (int i = 1; i < ratings.length; i++) {
            if (ratings[i] > ratings[i - 1]) {
                candyVec[i] = candyVec[i - 1] + 1;
            } else {
                candyVec[i] = 1;
            }
        }

        for (int i = ratings.length - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1]) {
                candyVec[i] = Math.max(candyVec[i], candyVec[i + 1] + 1);
            }
        }

        int ans = 0;
        for (int s : candyVec) {
            ans += s;
        }
        return ans;
    }
}
```



#### 7、箭射气球

[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if (points.length == 0) return 0;
        Arrays.sort(points, (o1, o2) -> Integer.compare(o1[0], o2[0])); 

        int count = 1;
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > points[i - 1][1]) {
                count++;
            } else {
                points[i][1] = Math.min(points[i][1],points[i - 1][1]); //记得更新右边界
            }
        }
        return count;
    }
}
```

注意这里的排序比较函数，由于`-2^31 <= xstart < xend <= 2^31 - 1`，所以，返回相减的数可能造成溢出，需要按照题解这样，或者是下面这样写。

```java
		Arrays.sort(points, (a, b)->{
            if (a[0] == b[0]) return a[1] > b[1] ? 1 : -1;
            return a[0] > b[0] ? 1 : -1;
        });
```



#### 8、划分字母区间

[763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)

```java
class Solution {
    public List<Integer> partitionLabels(String S) {
        List<Integer> list = new LinkedList<>();
        int[] edge = new int[26];
        char[] chars = S.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            edge[chars[i] - 'a'] = i;
        }
        int idx = 0;
        int last = -1;
        for (int i = 0; i < chars.length; i++) {
            idx = Math.max(idx,edge[chars[i] - 'a']);
            if (i == idx) {
                list.add(i - last);
                last = i;
            }
        }
        return list;
    }
}
```



#### 9、监测二叉树

[968. 监控二叉树](https://leetcode-cn.com/problems/binary-tree-cameras/)

首先需要从叶子节点往根节点考虑，因为根节点最多只有一个摄像头，而叶子节点摄像头数量是指数级别。然后还要考虑清楚空节点应该表示有覆盖的情况。然后最后，如果根节点还是未覆盖的状态的话，还要在根节点处加一个摄像头。

```java
class Solution {
    //0：无覆盖，1：有摄像头，2：有覆盖
    private int result = 0;
    public int minCameraCover(TreeNode root) {
        int rootNode = trave(root);
        if (rootNode == 0) result ++; //判断根节点是否未覆盖
        return result;
    }
    private int trave(TreeNode root) {
        if (root == null) return 2; //遇到空节点，则返回有覆盖状态
        int leftNode = trave(root.left);
        int rightNode = trave(root.right);

        if (leftNode == 0 || rightNode == 0) { //左右节点有一个无覆盖
            result ++;
            return 1;
        } else if (leftNode == 1 || rightNode == 1) { //左右节点有一个有摄像头
            return 2;
        } else if (leftNode == 2 && rightNode == 2) { //左右节点都覆盖
            return 0;
        }
        return -1;
    }
}
```



## 七、哈希表



### 1、数组当作哈希表使用

[1002. 查找共用字符](https://leetcode-cn.com/problems/find-common-characters/)

1、看清题目要求再动手

2、String.valueOf()可以将其它的类型转换成字符串类型

```
class Solution {
    public List<String> commonChars(String[] A) {
        List<String> result = new ArrayList<>();
        if (A.length == 0) return result;
        int[] hash= new int[26]; // 用来统计所有字符串里字符出现的最小频率
        for (int i = 0; i < A[0].length(); i++) { // 用第一个字符串给hash初始化
            hash[A[0].charAt(i)- 'a']++;
        }
        // 统计除第一个字符串外字符的出现频率
        for (int i = 1; i < A.length; i++) {
            int[] hashOtherStr= new int[26];
            for (int j = 0; j < A[i].length(); j++) {
                hashOtherStr[A[i].charAt(j)- 'a']++;
            }
            // 更新hash，保证hash里统计26个字符在所有字符串里出现的最小次数
            for (int k = 0; k < 26; k++) {
                hash[k] = Math.min(hash[k], hashOtherStr[k]);
            }
        }
        // 将hash统计的字符次数，转成输出形式
        for (int i = 0; i < 26; i++) {
            while (hash[i] != 0) { // 注意这里是while，多个重复的字符
                char c= (char) (i+'a');
                result.add(String.valueOf(c));
                hash[i]--;
            }
        }
        return result;
    }
}
```



### 2、哈希表的一些其它应用

[202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

题目中给出提示说：可能无限循环变不到1。注意理解，这里为什么会强调无限循环呢？因为有可能就是计算后变成了一个之前出现过的值，这样就相当于形成了一个环，这样才会造成无限循环的现象，所以，我们这里可以利用哈希表来处理，哈希表记录之前出现过的值，如果发现有，则会造成无限循环，否则就是可以计算出1的。

```java
class Solution {
    public boolean isHappy(int n) {
        Set<Integer> record = new HashSet<>();
        while (n != 1 && !record.contains(n)) {
            record.add(n);
            n = getNextNumber(n);
        }
        return n == 1;
    }

    private int getNextNumber(int n) {
        int res = 0;
        while (n > 0) {
            int temp = n % 10;
            res += temp * temp;
            n = n / 10;
        }
        return res;
    }
}
```



## 八、搜索与图论



### 1、DFS与BFS



#### 1、岛屿类问题

模板：

```
void dfs(int[][] grid, int r, int c) {
    // 判断是否超过边界
    if (!inArea(grid, r, c)) {
        return;
    }
    // 如果这个格子不是岛屿，直接返回
    if (grid[r][c] != 1) {
        return;
    }
    grid[r][c] = 2; // 将格子标记为「已遍历过」
    
    // 访问上、下、左、右四个相邻结点
    dfs(grid, r - 1, c);
    dfs(grid, r + 1, c);
    dfs(grid, r, c - 1);
    dfs(grid, r, c + 1);
}

// 判断坐标 (r, c) 是否在网格中
boolean inArea(int[][] grid, int r, int c) {
    return 0 <= r && r < grid.length 
        	&& 0 <= c && c < grid[0].length;
}
```

[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

```
class Solution {
    int n, m;
    int res;
    
    public int numIslands(char[][] grid) {
        n = grid.length;
        m = grid[0].length;
        res = 0;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                if (grid[i][j] == '1') {
                    res ++;
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

    private boolean inArea(int x, int y) {
        return 0 <= x && x < n && 0 <= y && y < m;
    }

    private void dfs(char[][] grid, int x, int y) {
        if (!inArea(x, y)) return;
        if (grid[x][y] == '0' || grid[x][y] == '2') return;

        grid[x][y] = '2';
        dfs(grid, x + 1, y);
        dfs(grid, x - 1, y);
        dfs(grid, x, y + 1);
        dfs(grid, x, y - 1);
    }
}
```

[463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)

岛屿周长可以巧妙地利用dfs来解答，岛屿的周长是计算岛屿全部的「边缘」，而这些边缘就是我们在 DFS 遍历中，dfs 函数返回的位置。观察题目示例，我们可以将岛屿的周长中的边分为两类，如下图所示。黄色的边是与网格边界相邻的周长，而蓝色的边是与海洋格子相邻的周长。

![](https://pic.leetcode-cn.com/66d817362c1037ebe7705aacfbc6546e321c2b6a2e4fec96791f47604f546638.jpg)

当我们的 dfs 函数因为「坐标 (r, c) 超出网格范围」返回的时候，实际上就经过了一条黄色的边；而当函数因为「当前格子是海洋格子」返回的时候，实际上就经过了一条蓝色的边。这样，我们就把岛屿的周长跟 DFS 遍历联系起来了。

```
class Solution {
    int n, m, res;
    public int islandPerimeter(int[][] grid) {
        n = grid.length;
        m = grid[0].length;
        res = 0;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                if (grid[i][j] == 1) {
                    dfs(grid, i, j);
                    return res;
                }
            }
        }
        return -1;
    }
    private boolean inArea(int x, int y) {
        return 0 <= x && x < n && 0 <= y && y < m;
    }
    private void dfs(int[][] grid, int x, int y) {
        if (!inArea(x, y)) {
            res ++;
            return;
        }
        if (grid[x][y] == 0) {
            res ++;
            return;
        }
        if (grid[x][y] == 2) return;
        grid[x][y] = 2; //表示已经遍历过该节点
        dfs(grid, x + 1, y);
        dfs(grid, x - 1, y);
        dfs(grid, x, y + 1);
        dfs(grid, x, y - 1);
    }
}
```

当然，这道题用数学方法更好，对于每个岛屿，它应该都有四条边，当两个岛屿接壤时，会减少两条边，所以，我们可以先统计总共岛屿数量，以及接壤的边界数量，然后使用公式：`4 * land - 2 * border`来计算岛屿边地数量。

```
class Solution {
    public int islandPerimeter(int[][] grid) {
        int land = 0, border = 0;
        int n = grid.length, m = grid[0].length;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                if (grid[i][j] == 1) {
                    land ++;
                    // 计算接壤边界数量，只统计右边和下边的，这样可以避免重复统计
                    if ((i + 1 < n) && grid[i + 1][j] == 1) {
                        border ++;
                    }
                    if ((j + 1) < m && grid[i][j + 1] == 1) {
                        border ++;
                    }
                }
            }
        }
        return 4 * land - 2 * border;
    }
}
```

[岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

```
class Solution {
    int n, m;
    int res, cur;
    
    public int maxAreaOfIsland(int[][] grid) {
        n = grid.length;
        m = grid[0].length;
        res = 0;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                if (grid[i][j] == 1) {
                    cur = 0;
                    dfs(grid, i, j);
                    res = res > cur ? res : cur;
                }
            }
        }
        return res;
    }

    private boolean inArea(int x, int y) {
        return 0 <= x && x < n && 0 <= y && y < m;
    }

    private void dfs(int[][] grid, int x, int y) {
        if (!inArea(x, y)) return;
        if (grid[x][y] == 0 || grid[x][y] == 2) return;

        grid[x][y] = 2;
        cur ++;
        dfs(grid, x + 1, y);
        dfs(grid, x - 1, y);
        dfs(grid, x, y + 1);
        dfs(grid, x, y - 1);
    }
}
```

[827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/)

该题先要统计每个岛的大小，然后再遍历一遍每个水域，假设将其填为岛屿，最大的岛屿面积是多少。

![](https://pic.leetcode-cn.com/56ec808215d4ff3014476ef22297522b3731602266f9a069a82daf41001f904c.jpg)

这里有个问题，就是当水域和同一个岛屿多次接壤时，应该只统计一次该岛屿面积，不能多次统计。所以，我们需要对每个岛屿进行标记，避免重复统计。

```
class Solution {
    int n, m;
    int curArea;
    int[] arr = new int[500 * 500];
    int res = 0;
    public int largestIsland(int[][] grid) {
        n = grid.length;
        m = grid[0].length;
        int k = 2;
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                if (grid[i][j] == 1) {
                    curArea = 0;
                    dfs(grid, i, j, k);
                    arr[k] = curArea;
                    k ++;
                    res = res > curArea ? res : curArea;
                }
            }
        }
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                if (grid[i][j] == 0) {
                    int tmp = 1; //1表示该水域填成岛屿的1个面积
                    Set<Integer> set = new HashSet<>(); //等级已经统计过的岛屿，避免重复统计
                    if (i + 1 < n && !set.contains(grid[i + 1][j])) {
                        tmp += arr[grid[i + 1][j]];
                        set.add(grid[i + 1][j]);
                    }
                    if (i - 1 >= 0 && !set.contains(grid[i - 1][j])) {
                        tmp += arr[grid[i - 1][j]];
                        set.add(grid[i - 1][j]);
                    }
                    if (j + 1 < m && !set.contains(grid[i][j + 1])) {
                        tmp += arr[grid[i][j + 1]];
                        set.add(grid[i][j + 1]);
                    }
                    if (j - 1 >= 0 && !set.contains(grid[i][j - 1])) {
                        tmp += arr[grid[i][j - 1]];
                        set.add(grid[i][j - 1]);
                    }
                    res = res > tmp ? res : tmp;
                }
            }
        }
        return res;
    }
    private boolean inArea(int x, int y) {
        return 0 <= x && x < n && 0 <= y && y < m;
    }
    private void dfs(int[][] grid, int x, int y, int k) { //用k来标记每个岛屿，即同一个岛屿的1都变成k
        if (!inArea(x, y)) return;
        if (grid[x][y] == 0 || grid[x][y] > 1) return; //grid[x][y] > 1表示已经遍历过该节点
        grid[x][y] = k;
        curArea ++;
        dfs(grid, x + 1, y, k);
        dfs(grid, x - 1, y, k);
        dfs(grid, x, y + 1, k);
        dfs(grid, x, y - 1, k);
    }
}
```



### 3、树与图的存储

树是一种特殊的图，与图的存储方式相同。对于无向图中的边ab，存储两条有向边a->b, b->a。因此我们可以只考虑有向图的存储。

![](E:/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9B%BE%E5%BA%93/asdfaasd.png)

模板：

```c++
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;
//h[i]链接的是第i个节点的子节点或者第i个数所能到达的节点集合
//e[idx]存储的是第idx个元素的具体值
//ne[idx]存储h链表上第idx个元素的下一个元下标

// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
for (int i = 0; i < N; i ++) h[i] = -1;
```

注意：这里h和ne中存储的都是下标，当我们要获得实际连接值时得返回到e中去获取。当表示单链表时，可以直接声明一个head节点来链接。



### 4、拓扑排序

如果图中有环，则肯定不能形成拓扑排序，因为有环的话，环中的节点的入度是无法等于0的，所以是无法入队列的，这时，tt就不会等于 n - 1.

模板：

```c++
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 数组存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```

例题：[848. 有向图的拓扑序列 - AcWing题库](https://www.acwing.com/problem/content/850/)。

解答：

```c++
#include<iostream>
#include<cstring>

using namespace std;
 
const int N = 100010;

int n, m;
int q[N], d[N], h[N], e[N], ne[N], idx; //q表示队列，d表示入度

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool topsort() {
    int hh = 0, tt = -1;
    
    for (int i = 1; i <= n; i++) {
        //将入度为0的节点插入队列
        if (!d[i]) q[++tt] = i;
    }
    while (hh <= tt) {
        int t = q[hh++];
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (--d[j] == 0) q[++tt] = j;
        }
    }
    return tt == n - 1;
}

int main() {
    memset(h, -1, sizeof h);
    cin >> n >> m;
    while (m--) {
        int a, b;
        cin >> a >> b;
        add(a, b);
        d[b]++;
    }
    
    if (topsort()) {
        for (int i = 0; i < n; i ++) cout << q[i] << " "; 
    }
    else {
        cout << -1;
    }
    return 0;
}
```



## 九、单调栈和单调队列



### 2、题目集和

#### 1、接雨水

[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

单调栈内只存储单调递减的数据，当遍历到的数大于栈顶元素时，要做弹出操作，即收集雨水。

```java
class Solution {
    public int trap(int[] height) {
        if (height.length <= 2) return 0;
        int res = 0;
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i < height.length; i ++) {
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                int cur = stack.pop();
                if (stack.isEmpty()) break; //此时说明左边没有比其大的值，也就收集不到雨水
                int h = Math.min(height[stack.peek()], height[i]) - height[cur];
                int w = i - stack.peek() - 1; //注意这一步要统计容器宽度
                res += h * w;
            }
            stack.push(i);
        }
        return res;
    }
}
```



## 十、常考题型



### 1、回文串



#### Ⅰ、动态规划

[647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

动态规划：`dp[i][j]`表示字符串s的第i-j个元素组成的子串是否为回文子串，是的话就是true，否则false。遍历字符串，我们有两种情况，第一是`s[i] != s[j]`，这时肯定`dp[i][j]`为false，其不是回文子串，第二种情况，`s[i] == s[j]`时，这时，如果i-j之间只有一个或者两个元素，则其肯定是回文子串，当i-j之间的元素大于2个时，就得看`dp[i + 1][j - 1]`的值了。

![647.回文子串](https://camo.githubusercontent.com/9cb222226e85be9b2772d59cbb1c7e1e0f3d263baf96134b8c0661008b56952c/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303132313137313033323437332e6a7067)

注意，这里由于`dp[i][j]`要用到`dp[i + 1][j - 1]`,所以i需要从后往前，或者先遍历j。目的就是得先求出`dp[i + 1][j - 1]`。

```java
class Solution {
    public int countSubstrings(String s) {
        int n = s.length();
        int ans = 0;
        boolean[][] dp = new boolean[n][n];
        for (int i = n - 1; i >= 0; i --) {
            for (int j = i; j < n; j ++) {
                if (s.charAt(i) == s.charAt(j)) {
                    if (j - i <= 1) {
                        ans ++;
                        dp[i][j] = true;
                    } else {
                        if (dp[i + 1][j - 1]) {
                            ans ++;
                            dp[i][j] = true;
                        }
                    }
                }
            }
        }
        return ans;
    }
}
```



[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

这里求回文子序列，可以定义`dp[i][j]`表示字符串i-j之间的子串的最长回文子序列，当`s[i] ==  s[j]`时，`dp[i][j] = dp[i + 1][j - 1] + 2`，当`s[i] != s[j]`时，此时可以比较`dp[i + 1][j]`和`dp[i][j - 1]`的最大值作为`dp[i][j]`的值。注意，初始化时需将`dp[i][i]`赋值为1，同时遍历时，j必须从i + 1开始遍历，同时，由于`dp[i][j]`要用到`dp[i + 1][j - 1]`，所以遍历顺序要注意。

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        for (int i = 0; i < n; i ++) dp[i][i] = 1;
        for (int i = n - 1; i >= 0; i --) {
            for (int j = i + 1; j < n; j ++) { //注意这里要是j = i + 1，因为j = i在初始化时已经赋值
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
}
```



#### Ⅱ、双指针

注意，双指针来判断时，要同时考虑两种情况：第i个元素单独作为中心；第i和第i+1两个元素作为中心。

```java
class Solution {
    public int countSubstrings(String s) {
        int res = 0;
        int n = s.length();
        for (int i = 0; i < n; i ++) {
            res += extend(s, i, i, n);
            res += extend(s, i, i + 1, n);
        }
        return res;
    }
    private int extend(String s, int i, int j, int n) {
        int cnt = 0;
        while (i >= 0 && j < n && s.charAt(i) == s.charAt(j)) {
            cnt ++;
            i --;
            j ++;
        }
        return cnt;
    }
}
```



#### Ⅲ、回溯

[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

本题有两个难点：一个是如何切割；另一个是判断回文串。

因为字符串中的每个字符都用到了，所以，可以按照第一个字符做一个字符串、前两个字符做一个字符串...所有字符作为一个字符串来切割，这样就可以对应到组合问题上。

判断回文串直接使用双向指针即可。

```java
class Solution {
    private List<List<String>> result = new ArrayList<>();
    private List<String> path = new ArrayList<>();

    public List<List<String>> partition(String s) {
        backtracking(s, 0);
        return result;
    }

    private void backtracking(String s, int startIndex) {
        if (startIndex >= s.length()) { //遍历到字符串最后位置，则保存结果
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = startIndex; i < s.length(); i ++) {
            if (!isPalindrom(s, startIndex, i)) continue; //不是回文串，直接进入下一个循环
            path.add(s.substring(startIndex, i + 1));
            backtracking(s, i + 1);
            path.remove(path.size() - 1);
        }
    }

    private boolean isPalindrom(String str, int startIndex, int endIndex) {
        for (int i = startIndex, j = endIndex; i < j; i ++, j --) {
            if (str.charAt(i) != str.charAt(j)) return false;
        }
        return true;
    }
}
```



### 2、二分查找

#### 1、整数二分

注意事项：

- 数组有序
- 若是更新l的话，必须`mid = l + r + 1 >> 1`，不然可能无限循环
- 都是执行`r = mid`或者`l = mid`

```
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
// r = mid时，就会不断贴近左边那个值
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
// l = mid时就会不断贴近右边那个值
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```



#### 2、浮点数二分



```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

例题：

![](E:/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/%E5%9B%BE%E5%BA%93/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220915133851.png)

解答：

```java
import java.math.BigDecimal;
import java.util.*;

public class 剪绳子 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt(), k = in.nextInt();
        double[] arr = new double[n];
        double totleLen = 0;
        for (int i = 0; i < n; i ++) {
            arr[i] = in.nextDouble();
            totleLen += arr[i];
        }
        double l = 0, r = totleLen;
        while (r - l > 1e-6) {
            double mid = l + (r - l) / 2.0;
            if (checkout(arr, mid, k)) l = mid;
            else r = mid;
        }
        BigDecimal res = new BigDecimal(r).setScale(2, BigDecimal.ROUND_FLOOR);
        System.out.printf("%.2f", res.doubleValue());
    }
    private static boolean checkout(double[] arr, double d, int k) {
        int cnt = 0;
        for (double a : arr) {
            cnt += a / d;
        }
        if (cnt >= k) return true;
        return false;
    }
}
```



### 3、二、三、四数之和

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

首先需要将数组排好序，然后利用双指针来实现遍历，当结果大于0时，右指针向左遍历，当结果小于0时，左指针向右遍历，直到两个指针相遇。这里主要考虑两个去重，第一步是考虑对 i 上元素的去重，也即第一个元素的去重；第二步是当左右指针各自的前后值重复了，需要去重处理。

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        if (nums == null || nums.length < 3) return result;
        Arrays.sort(nums);

        for (int i = 0; i < nums.length; i ++) {
            if (nums[i] > 0) return result; //当nums[i]大于0时，其后两个数字必大于0
           
            if (i > 0 && nums[i] == nums[i - 1]) continue; //第一个元素去重
            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum > 0) {
                    right --;
                } else if (sum < 0) {
                    left ++;
                } else {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    //第二个元素去重
                    while (left < right && nums[left] == nums[left + 1]) left ++;
                    //第三个元素去重
                    while (left < right && nums[right] == nums[right - 1]) right --;
                    // 找到答案时，双指针同时收缩
                    left ++;
                    right --;
                }
            }
        }
        return result;
    }
}
```



[18. 四数之和](https://leetcode-cn.com/problems/4sum/)

四数之和其实就是在三数之和的基础上再套上一层循环，不过，这里也会多一个去重的过程。

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<>();
        if (nums.length < 4) return result;
        //先将数组排好序
        Arrays.sort(nums);
        //处理逻辑
        for (int i = 0; i < nums.length; i ++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue; //第一个元素去重
            int sum = target - nums[i]; //剩下三数之和的值
            //遍历剩下数组
            for (int j = i + 1; j < nums.length; j ++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue; //第二个元素去重
                int left = j + 1, right = nums.length - 1;
                while (left < right) {
                    int tmp = nums[j] + nums[left] + nums[right];
                    if (tmp > sum) {
                        right --;
                    } else if (tmp < sum) {
                        left ++;
                    } else {
                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        while (left < right && nums[left + 1] == nums[left]) left ++;
                        while (left < right && nums[right - 1] == nums[right]) right --;
                        left ++;
                        right --;
                    }
                }
            }
        }
        return result;
    }
}
```



### 4、LRU缓存

实现LRUCache类，类中通过一个哈希表和一个双向链表来维护缓存。



先要定义一个双向链表，链表节点自定义，创建链表时，首尾各添加一个节点，这样就不用判断相邻节点是否存在。



类中包含三个对外接口：

`LRUCache(int capacity)`：构造函数，主要来限制缓存的容量大小；

`int get(int key)`：获取缓存中某个值；

`put(int key, int value)`往缓存中写入数据；



类中包含四个私有方法：

`void addToHead(DLinkedNode)`：将节点添加到链表头；

`void removeNode(DLinkedNode)`：删除节点；

`void moveToHead(DLinkedNode)`：当访问节点后将节点移动到链表头；

`DLinkedNode removeTail()`：超容量时，将链尾的节点移除，并返回，供哈希表删除相应数据；

```java
public class LRUCache {
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }

    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }

    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }

    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```

注意点：

- 在get()函数中，记得将该节点移动到队头；
- put()函数中，如果缓存中没有该节点，先要将该节点添加到队头，再判断有没有超容，超容再删除队尾节点；
- 在moveToHead()函数中，一定记得先删除该节点，再在队头添加该节点，顺序不能乱；



### 5、数组中重复数字或者单一数字求取

数组中所有数字都出现两次，只有一个数字或者两个数字出现一次，求解只出现一次的数字，例题如十四位运算1、异或运算，这种类型可以使用异或运算来求解。

数组中数字只出现一次，只有一个数字出现多次，求取该出现多次的数字。该题目可以使用链表判断是否有环，使用双指针来解答（数组中数字范围有约束），例题如四、双指针算法3、题目合集3.1、寻找重复数。



## 十一、剑指offer



### 59、剑指 Offer 59 - I. 滑动窗口的最大值

[剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

本题如果使用暴力的话，每一次滑窗都在窗口遍历求一次最大值，这样的时间复杂度为O(n*k)，我们可以使用一个单调队列来维护滑动窗口中的最大值，其中队列中需要保证是非严格递减的，该窗口的最大值存在队列的尾部，每次获取窗口最大值直接返回尾部元素即可。

- 怎么判断窗口每次滑动的那个下标是不是上一个窗口最大值？由于队列中窗口最大值存在队尾，我们只需判断队尾元素与我们的nums[i - 1]也就是我们窗口需要淘汰的那个元素是否相等，如果相等那就把队尾元素淘汰。因为我们的队列是非严格递减的，所以，如果队尾元素与nums[i - 1]相等的话，就一定是nums[i - 1]的值，需要淘汰。
- 每次加入新元素进来nums[j]，都需要维持队列的非严格递减，从队头遍历到队尾，将小于nums[j]的元素淘汰。
- 当我们的窗口形成后，将我们的窗口队列的队尾元素存储到结果数组中。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 0 || k == 0) return new int[0];
        Deque<Integer> deque = new LinkedList<>();
        int[] res = new int[nums.length - k + 1];

        for (int i = 1 - k, j = 0; j < nums.length; i ++, j ++) {
            //如果已经形成窗口，比较当前队列最大值是否是滑动窗口须淘汰的元素
            if (i > 0 && deque.peekLast() == nums[i - 1]) {
                deque.pollLast();
            }
            //保持队列递减
            //须从队头往队尾考虑
            while (!deque.isEmpty() && deque.peekFirst() < nums[j]) {
                deque.pollFirst();
            }
            deque.offerFirst(nums[j]);
            //当形成窗口后将窗口中的最大值保存进数组
            if (i >= 0) {
                res[i] = deque.peekLast();
            }    
        }
        
        return res;
    }
}
```



### 43、剑指 Offer 43. 1～n 整数中 1 出现的次数

[剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

将1~n当作一个整体，考虑个位、十位、百位...上1出现的次数，即为1~n整数中1出现的次数。

个位、十位、百位...上1出现的次数怎么求取呢？通过找规律来求：

将n分成三部分，高位、低位、当前位，如2304，当我们统计十位上1出现次数时，将23当作高位，0当作当前位，4当作低位。根据当前位，再分三种情况来进行判断：

1. 当 cur = 0时，此位 1 的出现次数只由高位决定：

![](https://pic.leetcode-cn.com/78e60b6c2ada7434ba69643047758e113fa732815f7c53791271c5e0f123687c-Picture1.png)

2、当cur=1时，此位1出现次数由高位和低位决定：

![](https://pic.leetcode-cn.com/58c7e6472155b49923b48daac10bd438b68e9504690cf45d5e739f3a8cb9cee1-Picture2.png)

3、当cur=2，3，...，9时，此位1出现次数由高位决定：

![](https://pic.leetcode-cn.com/0e51d37b434ef0ad93882cdcb832f867e18b872833c0c360ad4580eb9ed4aeda-Picture3.png)

题解：

```java
class Solution {
    public int countDigitOne(int n) {
        int high = n / 10;
        int cur = n % 10;
        int low = 0;
        int digit = 1;
        int res = 0;
        while (high != 0 || cur != 0) {
            if (cur == 0) {
                res += high * digit;
            } else if (cur == 1) {
                res += high * digit + low + 1;
            } else {
                res += (high + 1) * digit;
            }
            low += cur * digit;
            cur = high % 10;
            high /= 10;
            digit *= 10;
        }
        return res;
    }
}
```



## 十二、优先队列



### 1、求动态数组中位数

[剑指 Offer 41. 数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

该数据流是一个动态数据量，其在不断地插入数据，所以其中位数也在不断变化，该问题最大难点是怎么满足时间复杂度。

思路：

利用两个优先队列来存储数据，一个大根堆，一个小根堆，规定小根堆中的数据数量要么和大根堆一致，要么比大根堆多一个，这样有利于我们求中位数，小根堆中存储排序后较大的那一半数据，大根堆中存储排序后较小的那一半数据。

findMedian()：当我们需要求中位数时，当两个堆数据量一致，说明有偶数个数据，则返回两个堆顶数据的一般作为结果；当两个堆中数据不一致，则返回小根堆中数据作为结果；

addNum()：添加数据时，当两个堆中数据量不一致，则说明需要将一个数据添加到大根堆中，这个数据不一定是新添加的num，应该是重新排序后，中间两个数据中较小的那个数据。其实，有个很巧妙的方法来实现这个逻辑：**先将新添加的数据添加到小根堆中，然后取小根堆的堆顶元素，将其添加到大根堆中**。当两个堆中数据量相同，则说明需要将一个数据添加到小根堆中，和上述相同的实现逻辑，先将数据添加到大根堆中，再取大根堆堆顶元素添加到小根堆中。

```
class MedianFinder {

    Queue<Integer> p, q;

    /** initialize your data structure here. */
    public MedianFinder() {
        p = new PriorityQueue<>(); //小根堆
        q = new PriorityQueue<>(Collections.reverseOrder()); //大根堆
    }
    
    public void addNum(int num) {
        if (p.size() == q.size()) {
            q.offer(num);
            p.offer(q.poll());
        } else {
            p.offer(num);
            q.offer(p.poll());
        }
    }
    
    public double findMedian() {
        double res = 0.0;
        if (p.size() == q.size()) {
            res = (p.peek() + q.peek()) / 2.0;
        } else {
            res = p.peek();
        }
        return res;
    }
}
```



## 十三、找规律题目



### 1、旋转矩阵

[48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

对于矩阵中的某一点`(i, j)`，不妨设矩阵为`n × n`大小，则其顺时针旋转90°后的坐标为`(j, n - i - 1)`，该题中，我们需要一次性考虑四个点的坐标变化，它们之间是相关联的。所以，对于某一点`(i, j)`，我们考虑如下转换公式：

`(i, j) -> (j, n - i - 1) -> (n - i - 1, n - j - 1) -> (n - j - 1, i) - (i, j)`

同时，我们还要避免重复赋值，所以，每个点都只能考虑变换一次，我们需要选出一块区域的点作为起始点，这里需要分两种情况考虑：当n为偶数时，我们需要考虑左上角四分之一处作为起始区域；当n为奇数，我们考虑一块长方形区域作为起始区域，如下图所示；

<img src="https://assets.leetcode-cn.com/solution-static/48/1.png" style="zoom: 100%;" />

<img src="https://assets.leetcode-cn.com/solution-static/48/2.png" style="zoom:100%;" />

```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int x, y;
        if (n % 2 == 0) {
            x = n / 2;
            y = n / 2;
        } else {
            x = n / 2;
            y = n / 2 + 1;
        }
        for (int i = 0; i < x; i ++) {
            for (int j = 0; j < y; j ++) {
                int tmp= matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j- 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = tmp;
            }
        }
    }
}
```



我们还可以使用一种巧妙的方法来做，我们发现，当顺时针旋转90°时，我们只需将矩阵上下翻转后再对角线翻转，即可。

```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        //水平翻转
        for (int i = 0; i < n / 2; i ++) {
            for (int j = 0; j < n; j ++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n - i - 1][j];
                matrix[n - i - 1][j] = tmp;
            }
        }
        //对角线翻转
        for (int i = 0; i < n; i ++) {
            for (int j = i + 1; j < n; j ++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = tmp;
            }
        }
    }
}
```



## 十四、位运算



### 1、异或运算

异或运算有如下三个性质：

- 任何数与0做异或运算，结果仍然为原来的数，即`a ^ 0 = a`
- 任何数与自身异或，结果是0
- 异或运算满足交换律和结合律，即`a ^ b ^ a = b ^ a ^ a = b ^ (a ^ a) = b ^ 0 = b`
- `a ^ b = c`，则`a ^ c = b`

[136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

```
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int num : nums) {
            res ^= num;
        }
        return res;
    }
}
```

拓展：假设该数组中有两个只出现一次的数，找出来。

解析：

- 先对所有数字进行一次异或，得到两个出现一次的数字的异或值，这两个数不同，所以异或值肯定不等于0。
- 在异或结果中找到最右侧为 1 的位。
- 根据这一位对所有的数字进行分组。
- 在每个组内进行异或操作，得到两个数字。

```
class Solution {
    public int[] singleNumber(int[] nums) {
        int flag = 0;
        for (int num : nums) {
            flag ^= num; //获取该两个数的异或值
        }
        int rightOne = flag & (~flag + 1); //flag & (~flag + 1)可以求得最右侧为1的位
        int resOne = 0;
        for (int num : nums) {
            if ((num & rightOne) != 0) {
                resOne ^= num;
            }
        }

        return new int[]{resOne, resOne ^ flag}; //a ^ b = c，则 b = a ^ c
    }
}
```



## 十五、前缀和

前缀和可以节省计算子数组的和的时间，配合哈希表使用可以解决大部分子数组问题。

560.和为 K 的子数组：https://leetcode.cn/problems/subarray-sum-equals-k/

```
class Solution {
    public int subarraySum(int[] nums, int k) {
        int len = nums.length;
        int res = 0;
        int pre = 0;
        //键存前缀和，值存相同前缀和出现次数
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        for (int i = 0; i < len; i ++) {
            pre += nums[i];
            res += map.getOrDefault(pre - k, 0);
            int count = map.getOrDefault(pre, 0) + 1;
            map.put(pre, count);
        }
        return res;
    }
}
```



1248.统计「优美子数组」: https://leetcode.cn/problems/count-number-of-nice-subarrays/

```
class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        int res = 0, pre = 0, len = nums.length;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        for (int i = 0; i < nums.length; i ++) {
            if (nums[i] % 2 == 1) {
                pre ++;
            }
            if (map.containsKey(pre - k)) {
                res += map.get(pre - k);
            }
            int tmp = map.getOrDefault(pre, 0) + 1;
            map.put(pre, tmp);
        }
        return res;
    }
}
```



974.和可被 K 整除的子数组：https://leetcode.cn/problems/subarray-sums-divisible-by-k/

```
class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        int res = 0, pre = 0, len = nums.length;
        //键存储前缀和对k的取模，值存储次数
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        for (int i = 0; i < len; i ++) {
            pre += nums[i];
            int cur = (pre % k + k) % k; //被除数是负数取模会变成负数，需要特殊处理
            if (map.containsKey(cur)) {
                res += map.get(cur);
            }
            int tmp = map.getOrDefault(cur, 0) + 1;
            map.put(cur, tmp);
        }
        return res;
    }
}
```



523.连续的子数组和：https://leetcode.cn/problems/continuous-subarray-sum/

```
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int pre = 0, len = nums.length;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        for (int i = 0; i < len; i ++) {
            pre += nums[i];
            int cur = pre % k;
            if (map.containsKey(cur)) {
                if (i - map.get(cur) >= 2) return true;
                continue; //保留一个最靠近起始段的下标，这样能使得子数组最大，更能满足条件一
            }
            map.put(cur, i);
        }
        return false;
    }
}
```



## 十六、刷题小技巧

1、java、c++中取模的特殊处理

java和c++中，当除数与被除数可能为负数时，需要进行特殊处理：`(x % k + k) % k`

2、x & (-x + 1) 与 x & (x - 1)

`x & (-x + 1)`返回x的二进程表示的最右边的1，如x = 10110B，则`x & (-x + 1) = 00010B`

`x & (x - 1)`将二进程表示的x的最右边的1置为0，如x = 10110B，则`X & (x - 1) = 10100B`，其有如下妙用：

- 计算x转换成二进程中1的个数
- 判断一个数是否2的n次方（2的n次方最高位为1，其余位为0）











三、数组部分



1、二维数组的二分查找

对于有序二维数组，从右上角开始遍历，若比目标值大，则向左移动一位，若比目标值小，则向下移动一位，直到找到目标值为止。

有序二维数组：每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```







五、算法部分



1、二分法

1、整数二分法

整数二分法主要就是注意区间问题，一般有两种区间定义：左闭右闭、左闭右开

**左闭右闭**：

我们定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。

区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

- while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1；if (nums[middle] < target) left 要赋值为 middle + 1也是同理。

**左闭右开**：

定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。

有如下两点：

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]；if (nums[middle] < target) left 更新为middle + 1，理由与左闭右闭一样。

例题：LeetCode 704.二分查找

C++版：

```c++
// 左闭右闭
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

```c++
// 左闭右开
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```



Java版：

```java
//左闭右闭
class Solution {
    public int search(int[] nums, int target) {
        // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
        if (target < nums[0] || target > nums[nums.length - 1]) {
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;
    }
}
```

```java
//左闭右开
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length;
        while (left < right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target)
                return mid;
            else if (nums[mid] < target)
                left = mid + 1;
            else if (nums[mid] > target)
                right = mid;
        }
        return -1;
    }
}
```



建议直接采用下面模板解题：

**当数组里有重复元素时(没有重复元素也可以用)：**例题见34. 在排序数组中查找元素的第一个和最后一个位置

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
// r = mid时，就会不断贴近左边那个值
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
// l = mid时就会不断贴近右边那个值
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

这个代码模板有两个注意点：

- 寻找左边界时，用middle去赋值right，寻找右边界时，用middle去赋值left
- 寻找有边界时注意middle定义时得加1



2、浮点数二分法

浮点数二分法不用考虑区间问题，比较好处理，例题见69.x的平方根

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

有时，需求出浮点数对应的整数，比如69.x的平方根，这时，因为最终输出结果是个整数，所以可以用整数的方法来进行求解。

```c++
class Solution {
public:
    int mySqrt(int x) {
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long long)mid * mid <= x) { //细节一：小于等于
                ans = mid; //细节二：返回的是middle
                l = mid + 1; //细节三：l = middle + 1来判断是不是完全平方数
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
};
```



**牛顿迭代法：**

![](https://i.loli.net/2021/06/20/9ZYNIgpnXtzdDvi.png)

```c++
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }

        double C = x, x0 = x;
        while (true) {
            double xi = 0.5 * (x0 + C / x0); //迭代过程
            if (fabs(x0 - xi) < 1e-7) { //判断是否满足精度
                break;
            }
            x0 = xi;
        }
        return int(x0);
    }
};
```



总结：

- 对于二分法，需要清楚的是，最终都是在两个数之间进行判断，这样去思考细节会比较好把握。



2、DFS/BFS

对于深度优先算法，只需将其考虑成递归算法去思考即可，考虑每一个节点与其所有子节点之间的关系，这样思路就会很明确；

广度优先算法直接用队列，思路还是很明确的。



六、算法题部分



1、斐波那契数列

[题目链接](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)。

1、递归法

缺点：大量重复递归计算，例如f(n)和f(n-1)两者向下递归需要各自计算f(n-2)的值。

2、动态规划

```c++
class Solution {
public:
    int fib(int n) {
        if (n < 2) return n;
        int ans = 0, tempOne = 0, tempTwo = 1;
        for (int i = 2; i <= n; i ++) {
            ans = tempOne + tempTwo;
            ans %= (1000000007); //这一步去模和最后返回时取模效果一致，但是如果放在返回时取模的话这里的ans可能超限
            tempOne = tempTwo, tempTwo = ans;
        }
        return ans;
    }
};
```

3、矩阵快速幂

![image-20210927191821258](https://i.loli.net/2021/09/27/NxW3IQhLY7V5owy.png)







# java数据结构及用法总结

## 1、基本数据结构

### 1、数组

初始化
`int[] intArr = new int[]{1,2,3,4,5,6};`
`int[] intArr = {1,2,3,4,5,6};`
`int[] intArr = new int[6];`
`int[][] intMatrix = {{1,2},{3,4},{5,6}};`
`int[][] intMatrix = new int[3][2];`

获取数组长度
`int rowLength = intMatrix.length;`
`int colLength = intMatrix[0].length;`

**Arrays类的使用**

`import java.util.Arrays;`

`Arrays.fill(); //填充数组`

`Arrays.sort(); //数组排序`

`Arrays.toString(); //将数组中的内容全部打印出来`

`Arrays.equals(); //比较数组元素是否相等`

`Arrays.binarySearch(); //二分查找法找指定元素的索引值（下标）`

`Arrays.copeOf() 和Arrays.copeOfRange(); //截取数组`

更多见[链接](https://blog.csdn.net/weixin_41924879/article/details/100102009?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164112955616780274177840%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164112955616780274177840&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-100102009.pc_search_insert_es_download&utm_term=java%E4%B8%ADarrays%E7%B1%BB&spm=1018.2226.3001.4187)

### 2、字符

判断一个字符是否是数字字符
`Character.isDigit(char c)` 是则返回true，不是则返回false；

判断一个字符时候是字母
`Character.isLowerCase(char c)` LowerCase是小写                                                                                                                     

`Character.isUpperCase(char c)` UpperCase是大写；

判断一个字符是字母或数字
`Character.isLetterOrDigit(char c)`

将字母转换为大写
`Character.toUpperCase(char c);`

将字母转换为小写
`Character.toLowerCase(char c);`

### 3、String

##### 1、 初始化

String str;声明一个变量名为str的字符串

String str = "abcde";声明并初始化

##### 2、常用方法

1. `int length();`获取字符串的长度

2. `char charAt();`截取一个字符

3. `char[] toCharArray();`将字符串变成一个字符数组

4. `int indexOf(“字符或字符串”);`查找一个指定的字符串是否存在，返回的是字符串的位置，如果不存在，则返回-1

   str.indexof('字符',int index) ;查找str字符串中第index个字符
   str.lastIndexOf('s');查找str字符串中最后一个字符

5. `toUpperCase();`将字符串里面的小写字母变成大写字母

   `toLowerCase();`将字符串里面的大写字母变成小写字母

6. `String[] split(“字符”);`根据给定的正则表达式的匹配来拆分此字符串。形成一个新的String数组

7. `String trim();`去掉字符串左右空格

8. `String replace(char oldChar,char newChar);`新字符替换旧字符

   String replaceAll(String str1,Stringstr2);将某个内容全部替换成指定内容

   String replaceFirst(String str1,String str2);将第一次出现的某个内容替换成指定的内容

9. `String substring(int beginIndex,int endIndex);`截取字符串，包括beginIndex位置的，不包括endIndex位置

10. boolean equalsIgnoreCase(String str2);忽略大小写的比较两个字符串的值是否一模一样，返回一个布尔值

    bolean equals(String str2);比较两个字符串的值是否一模一样

11. `boolean contains(String str2);`判断一个字符串里面是否包含指定的内容，返回一个布尔值

12. boolean startsWith(String str);测试此字符串是否以指定的前缀开始。返回一个布尔值

    boolean endsWith(String str);测试此字符串是否以指定的后缀结束。返回一个布尔值
    
13. String str = String.valueOf();将其它类型转换成字符串；


##### 3、String、StringBuilder和StringBuffer

基本原则：如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer。

**StringBuilder:**

构造方法
public StringBuilder();
public StringBuilder(int capacity);
public StringBuilder(String str);

添加功能

`public StringBuilder append(String str);`
`public StringBuilder insert(int offset,String str);`

删除功能
`public StringBuffer deleteCharAt(int index);`
`public StringBuffer delete(int start,int end);`[start, end)

反转功能
`public StringBuilder reverse();`

修改功能

`public StringBuilder setCharAt(int index, char c);`

与String相互转换                                                                                                                                                                                                   

`StringBuilder sb = new StringBuilder(str);             `                                                                                                                                                                               `String str = sb.toString();`

**StringBuffer：**

构造方法
public StringBuffer();
public StringBuffer(int capacity);
public StringBuffer(String str);

添加功能
`public StringBuffer append(String str);`
`public StringBuffer insert(int offset,String str);`

删除功能
`public StringBuffer deleteCharAt(int index);`
`public StringBuffer delete(int start,int end);`[start, end)

反转功能
`public StringBuffer reverse();`

与String相互转换                                                                                                                                                                                                    

`StringBuffer sb = new StringBuffer(str);              `                                                                                                                                                                              `String str = sb.toString();`

[String、StringBuffer和StringBuilder的区别](https://blog.csdn.net/kingzone_2008/article/details/9220691?ops_request_misc=&request_id=&biz_id=102&utm_term=java%20stringbuffer%E5%92%8Cstringbuilde&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-9220691.pc_search_result_control_group&spm=1018.2226.3001.4187)

## 2、Collection接口

Collection接口是Set,List,Queue接口的父接口

Collection常用方法：

`add(Object o);`
`addAll(int index, Collection c);`在下标index处插入整个c
`clear();`
`contains(Object o);`
`size();`
`Collections.sort(Collection c);`                                                                                                                

`Collections.reverse(Collection c);`

```
//这里是是使用匿名内部类来完成的
Collections.sort(Collection c, new Comparator<String>() { //假如这里是对String类型的变量进行排序
    @Override
    public int compare(String o1, String o2) {
        //指定比较规则，按照首字母降序来排列
        return o2.charAt(0)-o1.charAt(0);
    }
});

//这里是使用lambda表达式来完成
Collections.sort(Collection c,(o1,o2)->{ return o2.charAt(o2.length()-1)-o1.charAt(o1.length()-1);}); //尾字母降序排列
```

### 1、List

`List<Object> list = new ArrayList<>();`

`List<Object> list = new ArrayList<Object>(map.values());`可以将哈希表的值作为一个list返回

boolean add(E e)	在末尾添加新元素

`list.add((int)index,Object o);`
`list.addAll(Collection<? extends E> c);`

boolean addAll(int index, Collection<? extends E> c)	在index位置插入c中所有元素

`list.get((int)index);`

E set(int index, E element)	将index位置的元素替换为新元素element，并返回老元素

`list.remove((int)index);`
`list.subList(int start,int end); `[start,end);                                                                                                                       

`list.isEmpty();`

`list.clear();`

`Object[] toArray()`	将集合转为对象数组

`boolean removeAll(Collection<?> c)`	删除集合中所有集合c中出现的元素

int size()	返回集合中存储的元素数量

int indexOf(Object o)	返回当前集合中顺序第一次出现的o元素
int lastIndexOf(Object o)	返回当前集合中逆序第一次出现的o元素

boolean contains(Object o)	当前集合中是否包含o元素
boolean containsAll(Collection<?> c)	当前集合中是否包含集合c中的所有元素(无关顺序和数量)

**LinkedList特有API：**

E removeFirst()	删除链表中第一个节点，返回删除节点存储的元素
E removeLast()	删除链表中最后一个节点，返回删除节点存储的元素
E getFirst()	返回链表中第一个节点的元素
E getLast()	返回链表中最后一个节点的元素
void addFirst(E e)	在链表头插入元素e
void addLast(E e)	在链表尾插入元素e

### 2、Stack

`Stack`继承`Vector`，`Vector`继承`AbstractList`同时实现了`List`接口，所以`List`接口定义的方法，`Stack`都可以调用。

 `Stack<E> stk = new Stack<E>();`

`E stack.push(E item);`                                                                                                                                                                                        

`E stack.pop();`
`E stack.peek();`

`boolean stack.isEmpty();`

`int stack.search(Object o);` //返回第一个o出现的位置，自栈顶向栈底，栈顶为1

### 3、Queue

定义：

`Queue<TreeNode> queue = new LinkedList<TreeNode>();`

队头插入元素：

`queue.offer();`

队尾删除元素并返回：

`queue.poll()`

判断是否为空：

`queue.isEmpty()`

求其元素个数：

`queue.size()`

求队尾元素：

`queue.peek();`

**优先队列**

按照堆的特点可以把堆分为大顶堆和小顶堆

大顶堆：每个结点的值都大于或等于其左右孩子结点的值

小顶堆：每个结点的值都小于或等于其左右孩子结点的值

```
public PriorityQueue(int initialCapacity, Comparator<? super E> comparator) {
    // Note: This restriction of at least one is not actually needed,
    // but continues for 1.5 compatibility
    if (initialCapacity < 1)
        throw new IllegalArgumentException();
    this.queue = new Object[initialCapacity];
    this.comparator = comparator;
}
```

默认小根堆，变成大根堆：

```
	//这里是是使用匿名内部类来完成的
	PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>(new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				/**以下是对比较器升序、降序的理解.
				 *(1) 写成return o1.compareTo(o2) 或者 return o1-o2表示升序
				 *(2) 写成return o2.compareTo(o1) 或者return o2-o1表示降序
				 */
				return o2.compareTo(o1);
			}		
		}) ;
	//这里是使用lambda表达式来完成
	PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((o1, o2) -> {return o2 - o1;});
```

`priorityqueue.add();`

`priorityqueue.remove();`

`priorityqueue.isEmpty();`

`priorityqueue.peek();`

`priorityqueue.size;`

不要用for去遍历优先队列，会乱序。

用数组表示队列：

```java
int hh = 0, tt = -1; //维护两个指针来表示队列的头和尾
int[] queue = new int[n]; //定义指定大小数组来表示队列

//offer()添加元素elem
queue[++ tt] = elem;
//poll()队尾删除并返回
int num = queue[hh ++];
//peek()返回队尾元素
int num = queue[hh];
//size()返回队列大小
tt - hh + 1;
//isEmpty()判断队列是否为空
return hh <= tt;
```

### 4、Set

Set不允许重复

`Set<Object> set = new HashSet<>();`

`Set<Object> set = new TreeSet<>();`有序,可以用Collections.reverseOrder()倒序

`set.add(Object o);`

`set.contains(Object o);`

`set.remove(Object o);`

`set.isEmpty();`

### 5、Deque

Deque是一个线性表接口，可以两端进行元素的插入和删除。使用Deque接口提供的方法就可以完成队列“先进先出”和堆栈“后进先出”的功能，Java堆栈Stack类已经过时，**Java官方推荐使用Deque替代Stack使用**。Deque堆栈操作方法：push()、pop()、peek()。

Deque是个接口，其实现类有：

- ArrayDeque，使用“数组”存储数据
- LinkedList，使用“链表”存储数据
- ConcurrentLinkedDeque，线程安全的LinkedList

![image-20211129164525729](https://i.loli.net/2021/11/29/kpe9xMcKXDaWJzF.png)

## 3、Map

`Map<String, Integer> map = new HashMap<>();`

`int size();`

`boolean isEmpty();`

`boolean containsKey(Object key);`

`boolean containsValue(Object value);`

`V get(Object key);`

`V put(K key, V value);`

`V remove(Object key);`

`void clear();`

`getOrDefault(key , defaultValue);`

`map.keySet()`获取key集合

`map.entrySet()`获取entry集合

`map.values()`获取value集合作为list返回

`Map<String, Integer> map = new TreeMap<>(Collections.reverseOrder());`map是有序的

entrySet()可以将TreeMap转成set，set中存储的是Map.Entry<String, Integer>类型的数据，使用getKey()、getValue()、setValue()操作该set中的元素

## 4、其它方法

### 1、排序

`Arrays.sort()`是经过调优排序算法，可对数字数组、字符数组等进行排序，性能能达到n*log(n)

Arrays.sort()重载了四类方法
sort(T[] a)：对指定T型数组按数字升序排序。
sort(T[] a,int formIndex, int toIndex)：对指定T型数组的指定范围按数字升序排序。
sort(T[] a, Comparator<? supre T> c): 根据指定比较器产生的顺序对指定对象数组进行排序。
sort(T[] a, int formIndex, int toIndex, Comparator<? supre T> c): 根据指定比较器产生的顺序对指定对象数组的指定对象数组进行排序。

```
//这里是是使用匿名内部类来完成的
Arrays.sort(arr, new Comparator<String>() { //假设这里对String类型进行排序
    @Override
    public int compare(String o1, String o2) {
        //指定比较规则，按照首字母降序来排列
        return o2.charAt(0)-o1.charAt(0);
    }
});

//这里是使用lambda表达式来完成
Arrays.sort(arr,(o1,o2)->{ return o2.charAt(o2.length()-1)-o1.charAt(o1.length()-1);});
```

### 2、int和String相互转换

int->String:
`String.valueOf(num)`

`Integer.toString(num)`

String->int:

`Integer.parseInt(str)`

`Integer.valueOf(str)`

### 3、数组与list转换

`List<V> list = Arrays.asList(V[] v);`v是String、Integer等，不可以用int、float等

`List<String> list = Arrays.asList("a", "b", "c");`

`List<Integer> list = Arrays.asList(1, 2, 3);`

`String[] arr = (String[])list.toArray(new String[size]);` //对于int类型不可用

### 4、java中定义Pair

```java
import java.util.*;

public class pairTest {
    private static class Pair <E extends Object, F extends Object>{
        private E first;
        private F second;

        public Pair(E first, F second) {
            this.first = first;
            this.second = second;
        }

        public E getFirst() {
            return first;
        }

        public void setFirst(E first) {
            this.first = first;
        }

        public F getSecond() {
            return second;
        }

        public void setSecond(F second) {
            this.second = second;
        }
    }

    public static void main(String[] args) {
        List<Pair<String, Integer>> list = new ArrayList<>();
        for (int i = 0; i < 10; i ++) {
            String str = "name" + (char)('A' + i);
            list.add(new Pair<>(str, i));
        }

        for (int i = 0; i < 10; i ++) {
            Pair<String, Integer> tmp = list.get(i);
            System.out.println(tmp.first + " " + tmp.second);
        }
    }
}
```

可以直接使用int[]，传入一个int[2]类型的数组对象即可。

```
Queue<int[]> queue = new LinkedList<>();
queue.offer(new int[]{1, 2});
int[] cur = queue.poll();
cur[0];
cur[1];
```

### 5、==与equals

在基本类型变量上，可以使用==来判断是否相等，当是对象类型或者包装类型和String类型变量时，要判断相等需要使用equals来判断。 
